<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LearnPython_week00：前言</title>
    <link href="/2021/02/09/LearnPython_week00/"/>
    <url>/2021/02/09/LearnPython_week00/</url>
    
    <content type="html"><![CDATA[<h3 id="一、Python安装"><a href="#一、Python安装" class="headerlink" title="一、Python安装"></a>一、Python安装</h3><div class="note note-success">            <p>任何高级语言都是需要一个自己的编程环境的，这就好比写字一样，需要有纸和笔，在计算机上写东西，也需要有文字处理软件，比如各种名称的OFFICE。笔和纸以及office软件，就是写东西的硬件或软件，总之，那些文字只能写在那个上边，才能最后成为一篇文章。那么编程也是，要有个什么程序之类的东西，要把程序写到那个上面，才能形成最后类似文章那样的东西。</p>          </div><p>所需要安装的东西，都在这个页面里面：<a href="http://www.python.org/downloads/">www.python.org/downloads/</a></p><blockquote><p><a href="http://www.python.org/">www.python.org</a> 是Python的官方网站，如果你的英语足够使用，那么自己在这里阅读，可以获得非常多的收获。<br>在Python的下载页面里面，显示出Python目前有两大类，一类是Python3.x.x，另外一类是Python2.7.x。可以说，Python3是未来，它比Python2.7有进步。</p></blockquote><h4 id="Linux系统的安装"><a href="#Linux系统的安装" class="headerlink" title="Linux系统的安装"></a>Linux系统的安装</h4><p>某些版本的linux中是自带Python的，在shell中输入Python，若出现&gt;&gt;&gt;并显示出Python的版本信息，恭喜你，这就进入到了Python的交互模式下（“交互模式”，这是一个非常有用的东西，从后面的学习中，你就能体会到，这里是学习Python的主战场）。</p><p>如果非要自己安装。参考下面的操作：</p><ul><li>到官方网站下载源码。比如：<br>wget <a href="http://www.python.org/ftp/python/2.7.8/Python-2.7.8.tgz">http://www.python.org/ftp/python/2.7.8/Python-2.7.8.tgz</a></li><li>解压源码包<br>tar -zxvf Python-2.7.8.tgz</li><li>编译<br>cd Python-2.7.8 ./configure –prefix=/usr/local #指定了目录，如果不制定，可以使用默认的，直接运行 ./configure 即可。 make&amp;&amp;sudo make install</li></ul><p>安装好之后，进入shell，输入python，会看到&gt;&gt;&gt;并显示出Python的版本信息</p><h4 id="windows系统的安装"><a href="#windows系统的安装" class="headerlink" title="windows系统的安装"></a>windows系统的安装</h4><p>到<a href="https://www.python.org/downloads/windows/">下载页面</a>里面找到windows安装包，下载之，比如下载了这个文件：Python 3.8.7。然后就是不断的“下一步”，即可完成安装。<br>特别注意，安装完之后，需要检查一下，在环境变量是否有Python。</p><p><em>新版本的Python安装过程中可自定义选择是否直接添加到环境变量，无需后续再去配置</em></p><blockquote><p>如果还不知道什么是windows环境变量，以及如何设置。不用担心，请去网页搜索一下，搜索：”windows 环境变量”就能找到如何设置了。</p></blockquote><p>以上搞定，在cmd中，输入Python，得到跟上面类似的结果，就说明已经安装好了。</p><h4 id="Mac-OS-X系统的安装"><a href="#Mac-OS-X系统的安装" class="headerlink" title="Mac OS X系统的安装"></a>Mac OS X系统的安装</h4><p>在Mac OS X平台上安装Python有多种方法。例如：</p><ul><li>Homebrew</li><li>安装文件（packaged binaries）</li><li>源代码安装</li></ul><p>上面是一般安装Python时最常见得几种方法，每一种都有各自的优势，下面我会详细介绍。</p><p>大部分情况下，安装Python 2和Python 3的过程还是略有不同，虽然大致差不多。因此，在安装时要注意自己需要的是哪个版本。</p><p>还要提醒大家注意的是，Mac OS X(10.8+)系统中已经预先安装了Python 2.7，所以下面的操作提示只有在你需要更新版本或者寻找更好地软件管理方式时才有用（比如说Homebrew）。</p><p><strong>通过Homebrew安装</strong></p><p>首先，如果你还不知道什么是Homebrew，而你用的又是Mac OS X系统，那么建议你先了解一下Homebrew。据其官网介绍，Homebrew是“OS X平台所欠缺的包管理器”。笔者认为，这个说法一点都不为过。<br>Homebrew可以让你通过命令行快速安装、更新、删除软件包，有点类似Ubuntu系统下的apt-get。这样，你安装各种软件时就会容易得多。例如，笔者就是通过homebrew安装了下面这些软件：android-sdk、go、mongodb、sqlite、git、imagemagick、lua和python3。</p><p>要安装Homebrew，只需跟着其网站的介绍操作即可。</p><p>既然你已经了解并安装了Homebrew，我们接下来就可以开始安装Python了。你可以通过Homebrew安装不同版本的Python，包括2.7.x和3.5.x。</p><p>安装Python 2.7的话，请输入：</p><p>$ brew install python<br>如果你选择使用Python 3，只需要将python替换成python3即可。想查看可以安装哪些Python版本的话，可以通过下面的命令在Homebrew上搜索：</p><p>$ brew search python<br>这个命令会列出可以安装的全部Python版本。</p><p><strong>通过安装包安装</strong></p><p>如果你想更新至最新的2.7.x或3.x版本，你可以直接从Python官网下载二进制安装文件。<br>然后选择需要的版本。Python 2和3的最新版本就在页面的顶部。选择好Python版本之后，你就能看到针对不同操作系统的安装包下载链接了。</p><p>我建议你下载相应系统的安装器，因为它会处理好所有的安装事宜，只需要确保下载了自己电脑CPU架构（32位或64位）对应的文件即可。笔者下载的则是Mac OS X 64位/32位安装器。</p><p>双击安装器之后，只要按照提示操作，就可以顺利安装Python。</p><p><strong>从源码安装Python</strong></p><p>最后一种，也是最少见的安装方式，就是从源码安装Python。大部分人都不会这样做，因为已经有现成的安装文件了。这种方法也只有在你真的需要自定义一些Python设置时，才会选择的安装方式。因为你在编译Python安装程序之前，可以进行部分设置。</p><p>下面就是从源码安装Python的相应步骤：</p><p>curl -OL<br>tar xzvf Python-2.7.11.tgz<br>cd Python-2.7.11<br>./configure –prefix=/usr/local –enable-shared<br>make<br>make install<br>安装时，请确保版本号与你希望使用的版本保持一致。</p><p>上面的操作同样也适用于从源码安装Python 3，只需要替换版本号即可。</p><h3 id="二、集成开发环境"><a href="#二、集成开发环境" class="headerlink" title="二、集成开发环境"></a>二、集成开发环境</h3><p>安装好Python之后，就已经可以进行开发了。按照惯例，第一行代码总是：Hello World</p><h4 id="值得纪念的时刻：Hello-world"><a href="#值得纪念的时刻：Hello-world" class="headerlink" title="值得纪念的时刻：Hello world"></a>值得纪念的时刻：Hello world</h4><p>不管你使用的是什么操作系统，肯定能够找到一个地方，运行Python，进入到交互模式。</p><p>像下面一样：</p><pre><code class="hljs angelscript">Microsoft Windows [版本 <span class="hljs-number">6.1</span><span class="hljs-number">.7601</span>]版权所有 (c) <span class="hljs-number">2009</span> Microsoft Corporation。保留所有权利。C:\Users\Administrator&gt;pythonPython <span class="hljs-number">3.4</span><span class="hljs-number">.4</span>rc1 (v3<span class="hljs-number">.4</span><span class="hljs-number">.4</span>rc1:<span class="hljs-number">04f</span>3f725896c, Dec  <span class="hljs-number">6</span> <span class="hljs-number">2015</span>, <span class="hljs-number">16</span>:<span class="hljs-number">42</span>:<span class="hljs-number">12</span>) [MSC v<span class="hljs-number">.1600</span> <span class="hljs-number">32</span> bit (Intel)] on win32Type <span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-string">&quot;copyright&quot;</span>, <span class="hljs-string">&quot;credits&quot;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;license&quot;</span> <span class="hljs-keyword">for</span> more information.&gt;&gt;&gt;</code></pre><p>在&gt;&gt;&gt;后面输入print “Hello, World”(3.0版本语法有所变化，print())，并按回车。这就是见证奇迹的时刻。</p><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">print(<span class="hljs-string">&quot;Hello,World&quot;</span>)</span>Hello,World</code></pre><p>如果你从来不懂编程，从这一刻起，就跨入了程序员行列；如果已经是程序员，那么就温习一下当初的惊喜吧！</p><p>Hello, World是你用代码向这个世界打招呼了。</p><p>每个程序员，都曾经历过这个伟大时刻，不经历这个伟大时刻的程序员不是伟大的程序员。为了纪念这个伟大时刻，理解其伟大之所在，下面将其内部行为逐一解说。</p><blockquote><p>说明：Python代码中常用到了一个符号：#，就是键盘上数字３上面的那个井字符。这个符号，在Python编程中，表示注释。所谓注释，就是在计算机不执行那句话，只是为了说明某行语句表达什么意思，是给计算机前面的人看的。特别提醒，在编程实践中，注释是必须的。</p></blockquote><div class="note note-danger">            <p>请牢记：程序在大多数情况下是给人看的，只是偶尔让计算机执行一下。</p>          </div><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 看到“&gt;&gt;&gt;”符号，表示Python做好了准备，等待你向她发出指令，让她做什么事情</span><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt;</span><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">print</span>，意思是打印。在这里也是这个意思，是要求Python打印什么东西</span><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt; <span class="hljs-built_in">print</span></span><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-string">&quot;Hello,World&quot;</span>是打印的内容，注意双引号，是英文状态下的。引号不是打印内容，它相当于一个包裹，把打印的内容包起来，统一交给Python。</span><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt; <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Hello, World&quot;</span>  <span class="hljs-comment"># python 3.x及以上版本语法为 print(&quot;Hello, World&quot;)</span></span><span class="hljs-meta">#</span><span class="bash">上面命令执行的结果。Python接收到你要求她所做的事情：打印Hello,World，于是她就老老实实地执行这个命令，丝毫不走样。</span>Hello, World</code></pre><p>在Python中，如果进入了上面的样式，我们称之为“交互模式”。这是非常有用而且简单的模式，她是我们进行各种学习和有关探索的好方式，随着学习的深入，你将更加觉得她魅力四射。</p><h4 id="集成开发环境"><a href="#集成开发环境" class="headerlink" title="集成开发环境"></a>集成开发环境</h4><p>虽然进入了程序员序列，但是，如果程序员用的这个工具，也仅仅是打印Hello,World，怎能用“伟大”来形容呢？</p><p>况且，这个工具也太简陋了？你看美工妹妹用的Photoshop，行政妹妹用的Word，出纳妹妹用的Excel，就连坐在老板桌后面的那个家伙还用一个PPT播放自己都不相信的新理念呢，难道我们伟大的程序员，就用这么简陋的工具写出旷世代码吗？</p><p>当然不是。软件是谁开发的？程序员。程序员肯定会先为自己打造好用的工具，这也叫做“近水楼台先得月”。</p><div class="note note-success">            <p>IDE的全称是：Integrated Development Environment，简称IDE，也称为Integration Design Environment、Integration Debugging Environment，翻译成中文叫做“集成开发环境”，在台湾那边叫做“整合開發環境”，它是一种辅助程序员开发用的应用软件。</p><p>维基百科这样对IDE定义：</p><p>IDE通常包括程式語言編輯器、自動建立工具、通常還包括除錯器。有些IDE包含編譯器／直譯器，如微软的Microsoft Visual Studio，有些则不包含，如Eclipse、SharpDevelop等，这些IDE是通过调用第三方编译器来实现代码的编译工作的。有時IDE還會包含版本控制系統和一些可以設計圖形用戶界面的工具。許多支援物件導向的現代化IDE還包括了類別瀏覽器、物件檢視器、物件結構圖。雖然目前有一些IDE支援多種程式語言（例如Eclipse、NetBeans、Microsoft Visual Studio），但是一般而言，IDE主要還是針對特定的程式語言而量身打造（例如Visual Basic）。</p>          </div><p>要想了解更多IDE的信息，推荐阅读维基百科中的词条</p><p>英文词条：Integrated development environment<br>中文词条：集成开发环境</p><h4 id="Python的IDE工具"><a href="#Python的IDE工具" class="headerlink" title="Python的IDE工具"></a>Python的IDE工具</h4><p>网上搜索一下：Python IDE，会发现，能够进行Python编程的IDE还真的不少。东西一多，就开始无所适从了。所有，有不少人都问用哪个IDE好。<br>那么做为零基础的学习者，用什么好呢？</p><p>既然是零基础，就别瞎折腾了，就用Python自带的IDLE。原因就是：简单。</p><p>Windows的朋友操作：“开始”菜单-&gt;“所有程序”-&gt;“Python 2.x(3.x)”-&gt;“IDLE（Python GUI）”来启动IDLE。启动之后，大概就可以看到</p><p>其它操作系统的用户，也都能在找到idle这个程序，启动之后，跟上面大致一样。</p><p>后面我们所有的编程，就在这里完成了。这就是伟大程序员用的第一个IDE。</p><p>除了这个自带的IDE，还有很多其它的IDE，列出来，供喜欢折腾的朋友参考</p><p>PythonWin: 是Python Win32 Extensions(半官方性质的Python for win32增强包)的一部分，也包含在ActivePython的windows发行版中。如其名字所言，只针对win32平台。<br>MacPython IDE: MacPythonIDE是Python的Mac OS发行版内置的IDE，可以看作是PythonWin的Mac对应版本，由Guido的哥哥Just van Rossum编写。(哥俩都很牛)<br>Emacs和Vim: Emacs和Vim号称是这个星球上最强大(以及第二强大)的文本编辑器，对于许多程序员来说是万能IDE的不二(三?)选择。<br>Eclipse + PyDev: Eclipse是新一代的优秀泛用型IDE，虽然是基于Java技术开发的，但出色的架构使其具有不逊于Emacs和Vim的可扩展性，现在已经成为了许多程序员最爱的瑞士军刀。<br>简单列几个，供参考，要找别的IDE，网上搜一下，五花八门，不少呢。</p><p><strong>有习惯使用idea的伙伴可以在idea中安装python插件一样可以进行代码编写，或者直接用JetBrains的另一款软件PyCharm</strong></p><p>磨刀不误砍柴工。IDE已经有了，伟大程序员就要开始从事伟大的编程工作了。</p>]]></content>
    
    
    <categories>
      
      <category>LearnPython</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LearnPython_week01：基本数据类型</title>
    <link href="/2021/02/09/LearnPython_week01/"/>
    <url>/2021/02/09/LearnPython_week01/</url>
    
    <content type="html"><![CDATA[<h3 id="一、数和四则运算"><a href="#一、数和四则运算" class="headerlink" title="一、数和四则运算"></a>一、数和四则运算</h3><h4 id="数"><a href="#数" class="headerlink" title="数"></a>数</h4><div class="note note-success">            <p>在python中，对数的规定比较简单，基本在小学数学水平即可理解。</p>          </div><p>那么，做为零基础学习这，也就从计算小学数学题目开始吧。因为从这里开始，数学的基础知识列位肯定过关了。</p><pre><code class="hljs angelscript">&gt;&gt;&gt; <span class="hljs-number">123</span><span class="hljs-number">123</span>&gt;&gt;&gt; <span class="hljs-number">3333333333333333333333333333333333333333</span><span class="hljs-number">3333333333333333333333333333333333333333</span>&gt;&gt;&gt; <span class="hljs-number">3.333</span><span class="hljs-number">3.333</span></code></pre><p>上面显示的是在交互模式下，如果输入3，就显示了3，这样的数称为整数，这个称呼和小学数学一样。</p><p>如果输入一个比较大的数，第二个，那么多个3组成的一个整数，在python中称之为长整数。在更早版本中为了表示某个数是长整数，python会在其末尾显示一个L。其实，现在的python已经能够自动将输入的很大的整数视为长整数了。你不必在这方面进行区别。</p><p>第三个，在数学里面称为小数，这里你依然可以这么称呼，不过就像很多编程语言一样，习惯称之为“浮点数”。至于这个名称的由来，也是有点说道的，有兴趣可以网上搜一下.</p><p>上述举例中，可以说都是无符号（或者说是非负数），如果要表示负数，跟数学中的表示方法一样，前面填上负号即可。</p><p>值得注意的是，我们这里说的都是十进制的数。</p><p>除了十进制，还有二进制、八进制、十六进制都是在编程中可能用到的，当然用六十进制的时候就比较少了（其实时间记录方式就是典型的六十进制）。</p><p>具体每个数字，在Python中都是一个对象，比如前面输入的3，就是一个对象。每个对象，在内存中都有自己的一个地址，这个就是它的身份。</p><div class="note note-success">            <p>用内建函数id()可以查看每个对象的内存地址，即身份。<br>内建函数，英文为built-in Function，读者根据名字也能猜个八九不离十了。不错，就是Python中已经定义好的内部函数。</p>          </div><pre><code class="hljs angelscript">&gt;&gt;&gt; id(<span class="hljs-number">123</span>)<span class="hljs-number">1713171224</span>&gt;&gt;&gt; id(<span class="hljs-number">3.111</span>)<span class="hljs-number">42519264</span>&gt;&gt;&gt; id(<span class="hljs-number">3</span>)<span class="hljs-number">1713169304</span>&gt;&gt;&gt; id(<span class="hljs-number">3.0</span>)<span class="hljs-number">42518864</span></code></pre><p>以上四个不同的数字，是四个不同的对象，具有四个不同的内存地址。特别要注意，在数学上，3和3.0是相等的，但是在这里，它们是不同的对象。 用id()得到的内存地址，是只读的，不能修改。</p><div class="note note-success">            <p>了解了“身份”，再来看“类型”，也有一个内建函数供使用type()。</p>          </div><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; type(<span class="hljs-number">3</span>)&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">int</span>&#x27;&gt;</span><span class="hljs-meta">&gt;&gt;</span>&gt; type(<span class="hljs-number">3.0</span>)&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">float</span>&#x27;&gt;</span><span class="hljs-meta">&gt;&gt;</span>&gt; type(<span class="hljs-number">3.222222</span>)&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">float</span>&#x27;&gt;</span><span class="hljs-meta">&gt;&gt;</span>&gt; type(<span class="hljs-string">&#x27;hello&#x27;</span>)&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">str</span>&#x27;&gt;</span></code></pre><p>用内建函数能够查看对象的类型。，说明3是整数类型（Interger）；则告诉我们那个对象是浮点型（Floating point real number）。与id()的结果类似，type()得到的结果也是只读的。</p><p>至于对象的值，在这里就是对象本身了。</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>仅仅写出3、4、5是远远不够的，在编程语言中，经常要用到“变量”和“数”（在python中严格来讲是对象）建立一个对应关系。例如：</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; x = <span class="hljs-number">5</span><span class="hljs-meta">&gt;&gt;</span>&gt; x<span class="hljs-number">5</span><span class="hljs-meta">&gt;&gt;</span>&gt; x = <span class="hljs-number">6</span><span class="hljs-meta">&gt;&gt;</span>&gt; x<span class="hljs-number">6</span><span class="hljs-meta">&gt;&gt;</span>&gt; y = <span class="hljs-number">123</span><span class="hljs-meta">&gt;&gt;</span>&gt; y</code></pre><p>在这个例子中，x = 5就是在变量(x)和数(5)之间建立了对应关系，接着又建立了x与6之间的对应关系。我们可以看到，x先“是”5，后来“是”6。</p><p>在python中，有这样一句话是非常重要的：对象有类型，变量无类型。怎么理解呢？</p><p>首先，5、6都是整数，python中为它们取了一个名字，叫做“整数”类型的数据，或者说数据类型是整数，用int表示。</p><p>当我们在python中写入了5、6，computer姑娘就自动在她的内存中某个地方给我们建立这两个对象（对象的定义后面会讲，这里你先用着，逐渐就明晰含义了），就好比建造了两个雕塑，一个是形状似5，一个形状似6，这就两个对象，这两个对象的类型就是int.</p><p>那个x呢？就好比是一个标签，当x = 5时，就是将x这个标签拴在了5上了，通过这个x，就顺延看到了5，于是在交互模式中，&gt;&gt;&gt; x输出的结果就是5，给人的感觉似乎是x就是5，事实是x这个标签贴在5上面。同样的道理，当x = 6时，标签就换位置了，贴到6上面。</p><p>所以，这个标签x没有类型之说，它不仅可以贴在整数类型的对象上，还能贴在其它类型的对象上，比如后面会介绍到的str（字符串）类型的对象等等。</p><p>这是python区别于一些语言非常重要的地方。</p><h4 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h4><p>按照下面要求，在交互模式中运行，看看得到的结果和用小学数学知识运算之后得到的结果是否一致</p><pre><code class="hljs angelscript">&gt;&gt;&gt; <span class="hljs-number">1</span>+<span class="hljs-number">1</span><span class="hljs-number">2</span>&gt;&gt;&gt; <span class="hljs-number">10</span><span class="hljs-number">-1</span><span class="hljs-number">9</span>&gt;&gt;&gt; <span class="hljs-number">20</span>/<span class="hljs-number">4</span><span class="hljs-number">5.0</span>&gt;&gt;&gt; <span class="hljs-number">10</span>*<span class="hljs-number">2</span><span class="hljs-number">20</span>&gt;&gt;&gt; <span class="hljs-number">10</span>/<span class="hljs-number">5</span>+<span class="hljs-number">1</span><span class="hljs-number">3.0</span>&gt;&gt;&gt; <span class="hljs-number">2</span>*<span class="hljs-number">3</span><span class="hljs-number">-4</span><span class="hljs-number">2</span></code></pre><p>上面的运算中，分别涉及到了四个运算符号：加(+)、减(-)、乘(*)、除(/)</p><p>另外，我相信看官已经发现了一个重要的公理：</p><p>在计算机中，四则运算和小学数学中学习过的四则运算规则是一样的</p><p>要不说人是高等动物呢，自己发明的东西，一定要继承自己已经掌握的知识，别跟自己的历史过不去。伟大的科学家们，在当初设计计算机的时候就想到列位现在学习的需要了，一定不能让后世子孙再学新的运算规则，就用小学数学里面的好了。感谢那些科学家先驱者，泽被后世。</p><p>下面计算三个算术题，看看结果是什么</p><ul><li>4 + 2</li><li>4.0 + 2</li><li>4.0 + 2.0<br>看官可能愤怒了，这么简单的题目，就不要劳驾计算机了，太浪费了。</li></ul><p>别着急，还是要运算一下，然后看看结果，有没有不一样？要仔细观察哦。</p><pre><code class="hljs angelscript">&gt;&gt;&gt; <span class="hljs-number">4</span>+<span class="hljs-number">2</span><span class="hljs-number">6</span>&gt;&gt;&gt; <span class="hljs-number">4.0</span>+<span class="hljs-number">2</span><span class="hljs-number">6.0</span>&gt;&gt;&gt; <span class="hljs-number">4.0</span>+<span class="hljs-number">2.0</span><span class="hljs-number">6.0</span></code></pre><p>不一样的地方是：第一个式子结果是6，这是一个整数；后面两个是6.0，这是浮点数。</p><p>定义1：类似4、-2、129486655、-988654、0这样形式的数，称之为整数 定义2：类似4.0、-2.0、2344.123、3.1415926这样形式的数，称之为浮点数</p><p>对这两个的定义，不用死记硬背，网上搜一下。记住爱因斯坦说的那句话：书上有的我都不记忆（是这么的说？好像是，大概意思，反正我也不记忆）。后半句他没说，我补充一下：忘了就网上搜一下。</p><h4 id="整数溢出问题"><a href="#整数溢出问题" class="headerlink" title="整数溢出问题"></a>整数溢出问题</h4><div class="note note-success">            <p>似乎计算机做一些四则运算是不在话下的，但是，有一个问题请你务必注意：在数学中，整数是可以无限大的，但是在计算机中，整数不能无限大。为什么呢？（我推荐你去google，其实计算机的基本知识中肯定学习过了。）因此，就会有某种情况出现，就是参与运算的数或者运算结果超过了计算机中最大的数了，这种问题称之为“整数溢出问题”。</p>          </div><p>对于其它语言，整数溢出是必须正视的，但是，在python里面，看官就无忧愁了，原因就是python为我们解决了这个问题，请阅读拙文：<a href="https://github.com/qiwsir/algorithm/blob/master/big_int.md">大整数相乘</a></p><p>ok!看官可以在IDE中实验一下大整数相乘。</p><pre><code class="hljs angelscript">&gt;&gt;&gt; <span class="hljs-number">1234567898765432123456789</span>*<span class="hljs-number">1234567898765432123456789</span><span class="hljs-number">1524157896662094260021335314738613077274750190521</span>&gt;&gt;&gt; <span class="hljs-number">12333333333333333333333333333333333333333333</span>*<span class="hljs-number">3211111111111111111111111111111111111111111111111111</span><span class="hljs-number">39603703703703703703703703703703703703703702633333331962962962962962962962962962962962962962963</span></code></pre><p>在结束本节之前，有两个符号需要看官牢记（不记住也没关系，可以随时google，只不过记住后使用更方便）</p><p>整数，用int表示，来自单词：integer<br>浮点数，用float表示，就是单词：float<br>可以用一个命令：type(object)来检测一个数是什么类型。</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; type(<span class="hljs-number">3</span>)&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">int</span>&#x27;&gt;<span class="hljs-comment">#3是int，整数</span></span><span class="hljs-meta">&gt;&gt;</span>&gt; type(<span class="hljs-number">3.0</span>)&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">float</span>&#x27;&gt;<span class="hljs-comment">#3.0是float，浮点数</span></span></code></pre><h3 id="二、除法"><a href="#二、除法" class="headerlink" title="二、除法"></a>二、除法</h3><h4 id="整数除以整数"><a href="#整数除以整数" class="headerlink" title="整数除以整数"></a>整数除以整数</h4><p>进入python交互模式之后（以后在本教程中，可能不再重复这类的叙述，只要看到&gt;&gt;&gt;，就说明是在交互模式下），练习下面的运算：</p><pre><code class="hljs angelscript"># python <span class="hljs-number">2.</span>x：&gt;&gt;&gt; <span class="hljs-number">2</span> / <span class="hljs-number">5</span><span class="hljs-number">0</span>&gt;&gt;&gt; <span class="hljs-number">2.0</span> / <span class="hljs-number">5</span><span class="hljs-number">0.4</span>&gt;&gt;&gt; <span class="hljs-number">2</span> / <span class="hljs-number">5.0</span><span class="hljs-number">0.4</span>&gt;&gt;&gt; <span class="hljs-number">2.0</span> / <span class="hljs-number">5.0</span><span class="hljs-number">0.4</span># python <span class="hljs-number">3.</span>x：&gt;&gt;&gt; <span class="hljs-number">2</span>/<span class="hljs-number">5</span><span class="hljs-number">0.4</span>&gt;&gt;&gt; <span class="hljs-number">2.0</span>/<span class="hljs-number">5</span><span class="hljs-number">0.4</span>&gt;&gt;&gt; <span class="hljs-number">2</span>/<span class="hljs-number">5.0</span><span class="hljs-number">0.4</span>&gt;&gt;&gt; <span class="hljs-number">2.0</span>/<span class="hljs-number">5.0</span></code></pre><p>看到没有？麻烦出来了（这是在python2.x中），按照数学运算，以上四个运算结果都应该是0.4。但我们看到的后三个符合，第一个居然结果是0。why?</p><p>因为，在python（严格说是python2.x中，python3会有所变化）里面有一个规定，像2/5中的除法这样，是要取整（就是去掉小数，但不是四舍五入）。2除以5，商是0（整数），余数是2（整数）。那么如果用这种形式：2/5，计算结果就是商那个整数。或者可以理解为：整数除以整数，结果是整数（商）。</p><p>比如：</p><pre><code class="hljs angelscript">&gt;&gt;&gt; <span class="hljs-number">5</span> / <span class="hljs-number">2</span><span class="hljs-number">2</span>&gt;&gt;&gt; <span class="hljs-number">7</span> / <span class="hljs-number">2</span><span class="hljs-number">3</span>&gt;&gt;&gt; <span class="hljs-number">8</span> / <span class="hljs-number">2</span><span class="hljs-number">4</span></code></pre><p><strong>注意：</strong>得到是商（整数）,而不是得到含有小数位的结果再通过“四舍五入”取整。例如：5/2，得到的是商2，余数1，最终5 / 2 = 2。并不是对2.5进行四舍五入。</p><h4 id="浮点数与整数相除"><a href="#浮点数与整数相除" class="headerlink" title="浮点数与整数相除"></a>浮点数与整数相除</h4><p>这个标题和上面的标题格式不一样，上面的标题是“整数除以整数”，如果按照风格一贯制的要求，本节标题应该是“浮点数除以整数”，但没有，现在是“浮点数与整数相除”，其含义是：</p><blockquote><p>假设：x除以y。其中 x 可能是整数，也可能是浮点数；y可能是整数，也可能是浮点数。</p></blockquote><p>出结论之前，还是先做实验：</p><pre><code class="hljs angelscript"># python <span class="hljs-number">2.</span>x：&gt;&gt;&gt; <span class="hljs-number">9.0</span> / <span class="hljs-number">2</span><span class="hljs-number">4.5</span>&gt;&gt;&gt; <span class="hljs-number">9</span> / <span class="hljs-number">2.0</span><span class="hljs-number">4.5</span>&gt;&gt;&gt; <span class="hljs-number">9.0</span> / <span class="hljs-number">2.0</span><span class="hljs-number">4.5</span>&gt;&gt;&gt; <span class="hljs-number">8.0</span> / <span class="hljs-number">2</span><span class="hljs-number">4.0</span>&gt;&gt;&gt; <span class="hljs-number">8</span> / <span class="hljs-number">2.0</span><span class="hljs-number">4.0</span>&gt;&gt;&gt; <span class="hljs-number">8.0</span> / <span class="hljs-number">2.0</span><span class="hljs-number">4.0</span># python <span class="hljs-number">3.</span>x：&gt;&gt;&gt; <span class="hljs-number">9.0</span>/<span class="hljs-number">2</span><span class="hljs-number">4.5</span>&gt;&gt;&gt; <span class="hljs-number">9</span>/<span class="hljs-number">2.0</span><span class="hljs-number">4.5</span>&gt;&gt;&gt; <span class="hljs-number">9.0</span>/<span class="hljs-number">2.0</span><span class="hljs-number">4.5</span>&gt;&gt;&gt; <span class="hljs-number">8.0</span>/<span class="hljs-number">2</span><span class="hljs-number">4.0</span>&gt;&gt;&gt; <span class="hljs-number">8</span>/<span class="hljs-number">2.0</span><span class="hljs-number">4.0</span>&gt;&gt;&gt; <span class="hljs-number">8.0</span>/<span class="hljs-number">2.0</span><span class="hljs-number">4.0</span></code></pre><p>归纳，得到规律：<strong>不管是被除数还是除数，只要有一个数是浮点数，结果就是浮点数。</strong>所以，如果相除的结果有余数，也不会像前面一样了，而是要返回一个浮点数，这就跟在数学上学习的结果一样了。</p><pre><code class="hljs angelscript">&gt;&gt;&gt; <span class="hljs-number">10.0</span> / <span class="hljs-number">3</span><span class="hljs-number">3.3333333333333335</span></code></pre><p>这个是不是就有点搞怪了，按照数学知识，应该是3.33333…，后面是3的循环了。那么你的计算机就停不下来了，满屏都是3。为了避免这个，python武断终结了循环，但是，可悲的是没有按照“四舍五入”的原则终止。当然，还会有更奇葩的出现：</p><pre><code class="hljs angelscript">&gt;&gt;&gt; <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span><span class="hljs-number">0.30000000000000004</span>&gt;&gt;&gt; <span class="hljs-number">0.1</span> + <span class="hljs-number">0.1</span> - <span class="hljs-number">0.2</span><span class="hljs-number">0.0</span>&gt;&gt;&gt; <span class="hljs-number">0.1</span> + <span class="hljs-number">0.1</span> + <span class="hljs-number">0.1</span> - <span class="hljs-number">0.3</span><span class="hljs-number">5.551115123125783e-17</span>&gt;&gt;&gt; <span class="hljs-number">0.1</span> + <span class="hljs-number">0.1</span> + <span class="hljs-number">0.1</span> - <span class="hljs-number">0.2</span><span class="hljs-number">0.10000000000000003</span></code></pre><p>越来越糊涂了，为什么computer姑娘在计算这么简单的问题上，如此糊涂了呢？不是computer姑娘糊涂，她依然冰雪聪明。原因在于十进制和二进制的转换上，computer姑娘用的是二进制进行计算，上面的例子中，我们输入的是十进制，她就要把十进制的数转化为二进制，然后再计算。但是，在转化中，浮点数转化为二进制，就出问题了。</p><p>例如十进制的0.1，转化为二进制是：0.0001100110011001100110011001100110011001100110011…</p><p>也就是说，转化为二进制后，不会精确等于十进制的0.1。同时，计算机存储的位数是有限制的，所以，就出现上述现象了。</p><p>这种问题不仅仅是python中有，所有支持浮点数运算的编程语言都会遇到，它不是python的bug。</p><p>明白了问题原因，怎么解决呢？就python的浮点数运算而言，大多数机器上每次计算误差不超过 2**53 分之一。对于大多数任务这已经足够了，但是要在心中记住这不是十进制算法，每个浮点数计算可能会带来一个新的舍入错误。</p><p>一般情况下，只要简单地将最终显示的结果用“四舍五入”到所期望的十进制位数，就会得到期望的最终结果。</p><p>对于需要非常精确的情况，可以使用 decimal 模块，它实现的十进制运算适合会计方面的应用和高精度要求的应用。另外 fractions 模块支持另外一种形式的运算，它实现的运算基于有理数（因此像1/3这样的数字可以精确地表示）。最高要求则可是使用由 SciPy提供的 Numerical Python 包和其它用于数学和统计学的包。列出这些东西，仅仅是让看官能明白，解决问题的方式很多，后面会用这些中的某些方式解决上述问题。</p><h4 id="引用模块解决除法–启用轮子"><a href="#引用模块解决除法–启用轮子" class="headerlink" title="引用模块解决除法–启用轮子"></a>引用模块解决除法–启用轮子</h4><p>python之所以受人欢迎，一个很重重要的原因，就是轮子多。这是比喻啦。就好比你要跑的快，怎么办？光天天练习跑步是不行滴，要用轮子。找辆自行车，就快了很多。还嫌不够快，再换电瓶车，再换汽车，再换高铁…反正你可以选择的很多。但是，这些让你跑的快的东西，多数不是你自己造的，是别人造好了，你来用。甚至两条腿也是感谢父母恩赐。正是因为轮子多，可以选择的多，就可以以各种不同速度享受了。</p><p>轮子是人类伟大的发明。</p><p>python就是这样，有各种轮子，我们只需要用。只不过那些轮子在python里面的名字不叫自行车、汽车，叫做“模块”，有人承接别的语言的名称，叫做“类库”、“类”。不管叫什么名字吧。就是别人造好的东西我们拿过来使用。</p><p>怎么用？可以通过两种形式用：</p><ul><li>形式1：import module-name。import后面跟空格，然后是模块名称，例如：import os</li><li>形式2：from module1 import module11。module1是一个大模块，里面还有子模块module11，只想用module11，就这么写了。</li></ul><p>不啰嗦了，实验一个：</p><pre><code class="hljs angelscript">&gt;&gt;&gt; <span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> division&gt;&gt;&gt; <span class="hljs-number">5</span> / <span class="hljs-number">2</span><span class="hljs-number">2.5</span>&gt;&gt;&gt; <span class="hljs-number">9</span> / <span class="hljs-number">2</span><span class="hljs-number">4.5</span>&gt;&gt;&gt; <span class="hljs-number">9.0</span> / <span class="hljs-number">2</span><span class="hljs-number">4.5</span>&gt;&gt;&gt; <span class="hljs-number">9</span> / <span class="hljs-number">2.0</span><span class="hljs-number">4.5</span># IDE工具写法<span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> divisionprint(<span class="hljs-number">5</span>/<span class="hljs-number">2</span>);print(<span class="hljs-number">9</span>/<span class="hljs-number">2</span>);print(<span class="hljs-number">9.0</span>/<span class="hljs-number">2</span>);print(<span class="hljs-number">9</span>/<span class="hljs-number">2.0</span>);# 结果<span class="hljs-number">2.5</span><span class="hljs-number">4.5</span><span class="hljs-number">4.5</span><span class="hljs-number">4.5</span></code></pre><div class="note note-success">            <p>注意了，引用了一个模块之后，再做除法，就不管什么情况，都是得到浮点数的结果了。<br>这就是轮子的力量。</p>          </div><h4 id="余数"><a href="#余数" class="headerlink" title="余数"></a>余数</h4><p>前面计算5/2的时候，商是2，余数是1</p><p>余数怎么得到？在python中（其实大多数语言也都是），用%符号来取得两个数相除的余数.</p><p>实验下面的操作：</p><pre><code class="hljs angelscript">&gt;&gt;&gt; <span class="hljs-number">5</span>%<span class="hljs-number">2</span><span class="hljs-number">1</span>&gt;&gt;&gt; <span class="hljs-number">6</span>%<span class="hljs-number">4</span><span class="hljs-number">2</span>&gt;&gt;&gt; <span class="hljs-number">5.0</span>%<span class="hljs-number">2</span><span class="hljs-number">1.0</span></code></pre><p>符号：%，就是要得到两个数（可以是整数，也可以是浮点数）相除的余数。</p><div class="note note-success">            <p>前面说python有很多人见人爱的轮子（模块），她还有丰富的内建函数，也会帮我们做不少事情。例如函数divmod()</p>          </div><pre><code class="hljs angelscript">&gt;&gt;&gt; divmod(<span class="hljs-number">5</span>,<span class="hljs-number">2</span>)# 表示<span class="hljs-number">5</span>除以<span class="hljs-number">2</span>，返回了商和余数(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)&gt;&gt;&gt; divmod(<span class="hljs-number">9</span>,<span class="hljs-number">2</span>)(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>)&gt;&gt;&gt; divmod(<span class="hljs-number">5.0</span>,<span class="hljs-number">2</span>)(<span class="hljs-number">2.0</span>, <span class="hljs-number">1.0</span>)</code></pre><h4 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入"></a>四舍五入</h4><p>要实现四舍五入，很简单，就是内建函数：round()</p><p>动手试试：</p><pre><code class="hljs angelscript">&gt;&gt;&gt; round(<span class="hljs-number">1.234567</span>,<span class="hljs-number">2</span>)<span class="hljs-number">1.23</span>&gt;&gt;&gt; round(<span class="hljs-number">1.234567</span>,<span class="hljs-number">3</span>)<span class="hljs-number">1.235</span>&gt;&gt;&gt; round(<span class="hljs-number">10.0</span>/<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<span class="hljs-number">3.3333</span></code></pre><p>简单吧。越简单的时候，越要小心，当你遇到下面的情况，就有点怀疑了：</p><pre><code class="hljs angelscript">&gt;&gt;&gt; round(<span class="hljs-number">1.2345</span>,<span class="hljs-number">3</span>)<span class="hljs-number">1.234</span>#应该是：<span class="hljs-number">1.235</span>&gt;&gt;&gt; round(<span class="hljs-number">2.235</span>,<span class="hljs-number">2</span>)<span class="hljs-number">2.23</span>#应该是：<span class="hljs-number">2.24</span></code></pre><p>具体解释看这里，下面摘录官方文档中的一段话：</p><blockquote><p>Note: The behavior of round() for floats can be surprising: for example, round(2.675, 2) gives 2.67 instead of the expected 2.68.<br>This is not a bug: it’s a result of the fact that most decimal fractions can’t be represented exactly as a float.<br><a href="https://docs.python.org/2/tutorial/floatingpoint.html#tut-fp-issues">See Floating Point Arithmetic: Issues and Limitations for more information.</a><br>译文：<br>注意:round()对于浮点数的行为可能会令人惊讶:例如，round(2.675,2)给出的是2.67而不是预期的2.68。<br>这不是bug:这是大多数小数不能用浮点数精确表示的结果。<br><a href="https://docs.python.org/2/tutorial/floatingpoint.html#tut-fp-issues">有关更多信息，请参阅浮点运算:问题和限制。</a></p></blockquote><p>归根到底还是浮点数中的十进制转化为二进制惹的祸。</p><h3 id="三、常用数字函数和运算优先级"><a href="#三、常用数字函数和运算优先级" class="headerlink" title="三、常用数字函数和运算优先级"></a>三、常用数字函数和运算优先级</h3><p>在数学之中，除了加减乘除四则运算之外——这是小学数学——还有其它更多的运算，比如乘方、开方、对数运算等等，要实现这些运算，需要用到python中的一个模块：Math</p><blockquote><p>模块(module)是python中非常重要的东西，你可以把它理解为python的扩展工具。<br>换言之，python默认情况下提供了一些可用的东西，但是这些默认情况下提供的还远远不能满足编程实践的需要，于是就有人专门制作了另外一些工具。<br>这些工具被称之为“模块” 任何一个pythoner都可以编写模块，并且把这些模块放到网上供他人来使用。<br>当安装好python之后，就有一些模块默认安装了，这个称之为“标准库”，“标准库”中的模块不需要安装，就可以直接使用。<br>如果没有纳入标准库的模块，需要安装之后才能使用。<br>模块的安装方法，我特别推荐使用pip来安装。这里仅仅提一下，后面会专门进行讲述，性急的看官可以自己网上搜索一下。</p></blockquote><h4 id="使用math模块"><a href="#使用math模块" class="headerlink" title="使用math模块"></a>使用math模块</h4><p>math模块是标准库中的，所以不用安装，可以直接使用。使用方法是：</p><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-keyword">import</span> math</span></code></pre><p>用import就将math模块引用过来了，下面就可以使用这个模块提供的工具了。比如，要得到圆周率：</p><pre><code class="hljs css">&gt;&gt;&gt; <span class="hljs-selector-tag">math</span><span class="hljs-selector-class">.pi</span>3<span class="hljs-selector-class">.141592653589793</span></code></pre><p>这个模块都能做哪些事情呢？可以用下面的方法看到：</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; dir(math)[<span class="hljs-string">&#x27;__doc__&#x27;</span>, <span class="hljs-string">&#x27;__loader__&#x27;</span>, <span class="hljs-string">&#x27;__name__&#x27;</span>, <span class="hljs-string">&#x27;__package__&#x27;</span>, <span class="hljs-string">&#x27;__spec__&#x27;</span>, <span class="hljs-string">&#x27;acos&#x27;</span>, <span class="hljs-string">&#x27;acosh&#x27;</span>, <span class="hljs-string">&#x27;asin&#x27;</span>, <span class="hljs-string">&#x27;asinh&#x27;</span>, <span class="hljs-string">&#x27;atan&#x27;</span>, <span class="hljs-string">&#x27;atan2&#x27;</span>, <span class="hljs-string">&#x27;atanh&#x27;</span>, <span class="hljs-string">&#x27;ceil&#x27;</span>, <span class="hljs-string">&#x27;copysign&#x27;</span>, <span class="hljs-string">&#x27;cos&#x27;</span>, <span class="hljs-string">&#x27;cosh&#x27;</span>, <span class="hljs-string">&#x27;degrees&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;erf&#x27;</span>, <span class="hljs-string">&#x27;erfc&#x27;</span>, <span class="hljs-string">&#x27;exp&#x27;</span>, <span class="hljs-string">&#x27;expm1&#x27;</span>, <span class="hljs-string">&#x27;fabs&#x27;</span>, <span class="hljs-string">&#x27;factorial&#x27;</span>, <span class="hljs-string">&#x27;floor&#x27;</span>, <span class="hljs-string">&#x27;fmod&#x27;</span>, <span class="hljs-string">&#x27;frexp&#x27;</span>, <span class="hljs-string">&#x27;fsum&#x27;</span>, <span class="hljs-string">&#x27;gamma&#x27;</span>, <span class="hljs-string">&#x27;hypot&#x27;</span>, <span class="hljs-string">&#x27;isfinite&#x27;</span>, <span class="hljs-string">&#x27;isinf&#x27;</span>, <span class="hljs-string">&#x27;isnan&#x27;</span>, <span class="hljs-string">&#x27;ldexp&#x27;</span>, <span class="hljs-string">&#x27;lgamma&#x27;</span>, <span class="hljs-string">&#x27;log&#x27;</span>, <span class="hljs-string">&#x27;log10&#x27;</span>, <span class="hljs-string">&#x27;log1p&#x27;</span>, <span class="hljs-string">&#x27;log2&#x27;</span>, <span class="hljs-string">&#x27;modf&#x27;</span>, <span class="hljs-string">&#x27;pi&#x27;</span>, <span class="hljs-string">&#x27;pow&#x27;</span>, <span class="hljs-string">&#x27;radians&#x27;</span>, <span class="hljs-string">&#x27;sin&#x27;</span>, <span class="hljs-string">&#x27;sinh&#x27;</span>, <span class="hljs-string">&#x27;sqrt&#x27;</span>, <span class="hljs-string">&#x27;tan&#x27;</span>, <span class="hljs-string">&#x27;tanh&#x27;</span>, <span class="hljs-string">&#x27;trunc&#x27;</span>]</code></pre><span class="label label-success">dir(module)</span> 是一个非常有用的指令，可以通过它查看任何模块中所包含的工具。从上面的列表中就可以看出，在math模块中，可以计算正sin(a),cos(a),sqrt(a)......<p>这些我们称之为函数，也就是在模块math中提供了各类计算的函数，比如计算乘方，可以使用pow函数。但是，怎么用呢？</p><p>python是一个非常周到的姑娘，她早就提供了一个命令，让我们来查看每个函数的使用方法：</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; help(math.pow)</code></pre><p>在交互模式下输入上面的指令，然后回车，看到下面的信息：</p><pre><code class="hljs gml">&gt;&gt;&gt; help(math.pow)Help on built-in function pow in module math:pow(...)    pow(<span class="hljs-symbol">x</span>, <span class="hljs-symbol">y</span>)        Return <span class="hljs-symbol">x</span>**<span class="hljs-symbol">y</span> (<span class="hljs-symbol">x</span> to the <span class="hljs-built_in">power</span> of <span class="hljs-symbol">y</span>).</code></pre><p>这里展示了math模块中的pow函数的使用方法和相关说明。</p><ol><li>第一行意思是说这里是math模块的内建函数pow帮助信息（所谓built-in，称之为内建函数，是说这个函数是python默认就有的)</li><li>第三行，表示这个函数的参数，有两个，也是函数的调用方式</li><li>第四行，是对函数的说明，返回x<strong>y的结果，并且在后面解释了x</strong>y的含义。</li><li>最后，按q键返回到python交互模式</li></ol><p>从上面看到了一个额外的信息，就是pow函数和x**y是等效的，都是计算x的y次方。</p><pre><code class="hljs angelscript">&gt;&gt;&gt; <span class="hljs-number">4</span>**<span class="hljs-number">2</span><span class="hljs-number">16</span>&gt;&gt;&gt; math.pow(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>)<span class="hljs-number">16.0</span>&gt;&gt;&gt; <span class="hljs-number">4</span>*<span class="hljs-number">2</span><span class="hljs-number">8</span># 特别注意，<span class="hljs-number">4</span>**<span class="hljs-number">2</span> 和  <span class="hljs-number">4</span>*<span class="hljs-number">2</span> 是有很大区别的。</code></pre><p>用类似的方法，可以查看math模块中的任何一个函数的使用方法。</p><blockquote><p>关于“函数”的问题，在这里不做深入阐述，看管姑且按照自己在数学中所学到去理解。后面会有专门研究函数的章节。</p></blockquote><p>下面是几个常用的math模块中函数举例，可以结合自己调试的进行比照。</p><pre><code class="hljs angelscript">&gt;&gt;&gt; math.sqrt(<span class="hljs-number">9</span>)<span class="hljs-number">3.0</span>&gt;&gt;&gt; math.floor(<span class="hljs-number">3.14</span>)<span class="hljs-number">3.0</span>&gt;&gt;&gt; math.floor(<span class="hljs-number">3.92</span>)<span class="hljs-number">3.0</span>&gt;&gt;&gt; math.fabs(<span class="hljs-number">-2</span>)    #等价于abs(<span class="hljs-number">-2</span>)<span class="hljs-number">2.0</span>&gt;&gt;&gt; abs(<span class="hljs-number">-2</span>)<span class="hljs-number">2</span>&gt;&gt;&gt; math.fmod(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>)    #等价于<span class="hljs-number">5</span>%<span class="hljs-number">3</span><span class="hljs-number">2.0</span>&gt;&gt;&gt; <span class="hljs-number">5</span>%<span class="hljs-number">3</span><span class="hljs-number">2</span></code></pre><h4 id="几个常见函数"><a href="#几个常见函数" class="headerlink" title="几个常见函数"></a>几个常见函数</h4><p>有几个常用的函数，列一下，如果记不住也不要紧，知道有这些就好了，用的时候就网上搜一下。<br><strong>求绝对值</strong></p><pre><code class="hljs angelscript">&gt;&gt;&gt; abs(<span class="hljs-number">10</span>)<span class="hljs-number">10</span>&gt;&gt;&gt; abs(<span class="hljs-number">-10</span>)<span class="hljs-number">10</span>&gt;&gt;&gt; abs(<span class="hljs-number">-1.2</span>)<span class="hljs-number">1.2</span></code></pre><p><strong>四舍五入</strong></p><pre><code class="hljs fortran">&gt;&gt;&gt; <span class="hljs-keyword">round</span>(<span class="hljs-number">1.234</span>)<span class="hljs-number">1.0</span>&gt;&gt;&gt; <span class="hljs-keyword">round</span>(<span class="hljs-number">1.234</span>,<span class="hljs-number">2</span>)<span class="hljs-number">1.23</span>&gt;&gt;&gt; #如果不清楚这个函数的用法，可以使用下面方法看帮助信息&gt;&gt;&gt; help(<span class="hljs-keyword">round</span>)Help on built-<span class="hljs-keyword">in</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword">round</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">module</span> builtins:<span class="hljs-keyword">round</span>(<span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span>)    <span class="hljs-keyword">round</span>(<span class="hljs-keyword">number</span>[, ndigits]) -&gt; <span class="hljs-keyword">number</span>        <span class="hljs-keyword">Round</span> a <span class="hljs-keyword">number</span> to a given <span class="hljs-keyword">precision</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">decimal</span> <span class="hljs-built_in">digits</span> (<span class="hljs-keyword">default</span> <span class="hljs-number">0</span> <span class="hljs-built_in">digits</span>)<span class="hljs-number">.</span>    This returns an <span class="hljs-built_in">int</span> when called with one argument, otherwise the    same <span class="hljs-keyword">type</span> as the <span class="hljs-keyword">number</span><span class="hljs-number">.</span> ndigits may be negative<span class="hljs-number">.</span></code></pre><h4 id="运算优先级"><a href="#运算优先级" class="headerlink" title="运算优先级"></a>运算优先级</h4><p>从小学数学开始，就研究运算优先级的问题，比如四则运算中“先乘除，后加减”，说明乘法、除法的优先级要高于加减。</p><p>对于同一级别的，就按照“从左到右”的顺序进行计算。</p><p>下面的表格中列出了python中的各种运算的优先级顺序。不过，就一般情况而言，不需要记忆，完全可以按照数学中的去理解，因为人类既然已经发明了数学，在计算机中进行的运算就不需要从新编写一套新规范了，只需要符合数学中的即可。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>lambda</td><td>Lambda表达式</td></tr><tr><td>or</td><td>布尔“或”</td></tr><tr><td>and</td><td>布尔“与”</td></tr><tr><td>not x</td><td>布尔“非”</td></tr><tr><td>in，not in</td><td>成员测试</td></tr><tr><td>is，is not</td><td>同一性测试</td></tr><tr><td>，&gt;=，!=，==</td><td>比较</td></tr><tr><td>∣</td><td>按位或</td></tr><tr><td>^</td><td>按位异或</td></tr><tr><td>&amp;</td><td>按位与</td></tr><tr><td>&gt;</td><td>移位</td></tr><tr><td>+，-</td><td>加法与减法</td></tr><tr><td>*，/，%</td><td>乘法、除法与取余</td></tr><tr><td>+x，-x</td><td>正负号</td></tr><tr><td>~x</td><td>按位翻转</td></tr><tr><td>**</td><td>指数</td></tr><tr><td>x.attribute</td><td>属性参考</td></tr><tr><td>x[index]</td><td>下标</td></tr><tr><td>x[index:index]</td><td>寻址段</td></tr><tr><td>f(arguments…)</td><td>函数调用</td></tr><tr><td>(experession,…)</td><td>绑定或元组显示</td></tr><tr><td>[expression,…]</td><td>列表显示</td></tr><tr><td>{key:datum,…}</td><td>字典显示</td></tr><tr><td>‘expression,…’</td><td>字符串转换</td></tr></tbody></table><p>上面的表格将python中用到的与运算符有关的都列出来了，是按照从低到高的顺序列出的。虽然有很多还不知道是怎么回事，不过先列出来，等以后用到了，还可以回来查看。</p><p>最后，要提及的是运算中的绝杀：括号。只要有括号，就先计算括号里面的。这是数学中的共识，无需解释。</p><h3 id="四、写一个简单的程序"><a href="#四、写一个简单的程序" class="headerlink" title="四、写一个简单的程序"></a>四、写一个简单的程序</h3><p>通过对四则运算的学习，已经初步接触了Python中内容，如果看官是零基础的学习者，可能有点迷惑了。<br>难道敲几个命令，然后看到结果，就算编程了？这也不是那些能够自动运行的程序呀？<br>的确。到目前为止，还不能算编程，只能算会用一些指令（或者叫做命令）来做点简单的工作。</p><div class="note note-success">            <p>开始编写一个真正的简单程序。</p>          </div><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><p>计算机程序</p><blockquote><p>计算机程序（Computer Program）是指一组指示计算机或其他具有信息处理能力装置每一步动作的指令，通常用某种程序设计语言编写，运行于某种目标体系结构上。<br>打个比方，一个程序就像一个用汉语（程序设计语言）写下的红烧肉菜谱（程序），用于指导懂汉语和烹饪手法的人（体系结构）来做这个菜。<br>通常，计算机程序要经过编译和链接而成为一种人们不易看清而计算机可解读的格式，然后运行。未经编译就可运行的程序，通常称之为脚本程序（script）。</p></blockquote><p>程序，简而言之，就是指令的集合。但是，有的程序需要编译，有的不需要。python编写的程序就不需要，因此她也被称之为解释性语言，编程出来的层序被叫做脚本程序。<br>在有的程序员头脑中，有一种认为“编译型语言比解释性语言高价”的认识。这是错误的。不要认为编译的就好，不编译的就不好；也不要认为编译的就“高端”，不编译的就属于“低端”。<br>有一些做了很多年程序的程序员或者其它什么人，可能会有这样的想法，这是毫无根据的。<br>不争论。用得妙就是好。</p><h4 id="使用IDE工具"><a href="#使用IDE工具" class="headerlink" title="使用IDE工具"></a>使用IDE工具</h4><p>见 <strong>LearnPython_day00：前言</strong>，选择合适的开发工具可以事半功倍</p><h4 id="解一道题目"><a href="#解一道题目" class="headerlink" title="解一道题目"></a>解一道题目</h4><p>请计算：19+2*4-8/2</p><p>代码如下：</p><pre><code class="hljs lsl"><span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;</span><span class="hljs-string">请计算：19+2*4-8/2</span><span class="hljs-string">&quot;</span><span class="hljs-string">&quot;&quot;</span>print(<span class="hljs-number">19</span>+<span class="hljs-number">2</span>*<span class="hljs-number">4</span><span class="hljs-number">-8</span>/<span class="hljs-number">2</span>);# 或：a = <span class="hljs-number">19</span>+<span class="hljs-number">2</span>*<span class="hljs-number">4</span><span class="hljs-number">-8</span>/<span class="hljs-number">2</span>;print(a)</code></pre><p>执行结果如下：</p><pre><code class="hljs angelscript"><span class="hljs-number">23.0</span><span class="hljs-number">23.0</span></code></pre><div class="note note-success">            <p>提醒初学者，别复制这段代码，而是要一个字一个字的敲进去。</p>          </div><p>下面对这个简单程序进行一一解释。</p><pre><code class="hljs awk"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">请计算：</span><span class="hljs-string">19+2*4-8/2</span><span class="hljs-string">&quot;&quot;&quot;</span></code></pre><p>这一行是让人看的，计算机看不懂。在python程序中（别的编程语言也是如此），要写所谓的注释，就是对程序或者某段语句的说明文字，这些文字在计算机执行程序的时候，被计算机姑娘忽略，但是，注释又是必不可少的，正如前面说的那样，程序在大多数情况下是给人看的。注释就是帮助人理解程序的。</p><p>写注释的方式有两种，一种是单行注释，用 <span class="label label-primary">#</span> 开头，另外一种是多行注释，用一对 <span class="label label-primary">"""</span> 包裹起来。</p><p>用 <span class="label label-primary">#</span> 开头的注释，可以像下面这样来写：</p><pre><code class="hljs angelscript"># 请计算：<span class="hljs-number">19</span>+<span class="hljs-number">2</span>*<span class="hljs-number">4</span><span class="hljs-number">-8</span>/<span class="hljs-number">2</span></code></pre><p>这种注释通常写在程序中的某个位置，比如某个语句的前面或者后面。计算机也会忽略这种注释的内容，只是给人看的。以#开头的注释，会在后面的编程中大量使用。<br><em>一般在程序的开头部分，都要写点东西，主要是告诉别人这个程序是用来做什么的。</em></p><pre><code class="hljs angelscript">a = <span class="hljs-number">19</span>+<span class="hljs-number">2</span>*<span class="hljs-number">4</span><span class="hljs-number">-8</span>/<span class="hljs-number">2</span></code></pre><p>所谓语句，就是告诉程序要做什么事情。程序就是有各种各样的语句组成的。这条语句，又有一个名字，叫做复制语句。</p><span class="label label-primary">19+2*4-8/2</span> 是一个表达式，最后要计算出一个结果，这个结果就是一个对象（又遇到了对象这个术语。在某些地方的方言中，把配偶、男女朋友也称之为对象，“对象”是一个应用很广泛的术语）。<span class="label label-primary">=</span> 不要理解为数学中的等号，它的作用不是等于，而是完成赋值语句中“赋值”的功能。<span class="label label-primary">a</span> 就是变量。这样就完成了一个赋值过程。<div class="note note-success">            <p>语句和表达式的区别：“表达式就是某件事”，“语句是做某件事”。</p>          </div><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a)</span></span></code></pre><p>这还是一个语句，称之为print语句，就是要打印出a的值（这种说法不是非常非常严格，但是通常总这么说。按照严格的说法，是打印变量a做对应的对象的值。嫌这种说法啰嗦，就直接说打印a的值）。</p><h3 id="五、字符串-1"><a href="#五、字符串-1" class="headerlink" title="五、字符串(1)"></a>五、字符串(1)</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><blockquote><p>字符串（String），是由零个或多个字符组成的有限串行。一般记为s=a[1]a[2]…a[n]。</p></blockquote><p>根据这个定义，在前面两次让一个程序员感到伟大的”Hello,World”，就是一个字符串。或者说不管用英文还是中文还是别的某种文，写出来的文字都可以做为字符串对待，当然，里面的特殊符号，也是可以做为字符串的，比如空格等。</p><p>严格地说，在python中的字符串是一种对象类型，这种类型用str表示，通常单引号’’或者双引号””包裹起来。</p><blockquote><p>字符串和前面讲过的数字一样，都是对象的类型，或者说都是值。当然，表示方式还是有区别的。</p></blockquote><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; <span class="hljs-string">&quot;I love Daimon&quot;</span><span class="hljs-string">&#x27;I love Daimon&#x27;</span><span class="hljs-meta">&gt;&gt;</span>&gt; <span class="hljs-string">&#x27;I love Daimon&#x27;</span><span class="hljs-string">&#x27;I love Daimon&#x27;</span></code></pre><p>从这两个例子中可以看出来，不论使用单引号还是双引号，结果都是一样的。</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; <span class="hljs-number">123</span><span class="hljs-number">123</span><span class="hljs-meta">&gt;&gt;</span>&gt; type(<span class="hljs-number">123</span>)&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">int</span>&#x27;&gt;</span><span class="hljs-meta">&gt;&gt;</span>&gt; <span class="hljs-string">&quot;123&quot;</span><span class="hljs-string">&#x27;123&#x27;</span><span class="hljs-meta">&gt;&gt;</span>&gt; type(<span class="hljs-string">&quot;123&quot;</span>)&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">str</span>&#x27;&gt;</span></code></pre><p>仔细观察上面的区别，同样是123，一个没有放在引号里面，一个放在了引号里面，用 <strong>type()</strong> 函数来检验一下，发现它们居然是两种不同的对象类型，前者是int类型，后者则是str类型，即字符串类型。<br>所以，请大家务必注意，不是所有数字都是int（or float）,必须要看看，它在什么地方，如果在引号里面，就是字符串了。<br>如果搞不清楚是什么类型，就让 <strong>type()</strong> 来帮忙搞定。</p><p>在print后面，打印的都是字符串。注意，是双引号里面的，引号不是字符串的组成部分。它是在告诉计算机，它里面包裹着的是一个字符串。</p><p>如果我要把下面这句话看做一个字符串，应该怎么做？</p><pre><code class="hljs vbnet">What<span class="hljs-comment">&#x27;s your name?</span></code></pre><p>在这句话中有一个单引号，如果直接在交互模式中像上面那样输入，就会这样：</p><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-string">&#x27;What&#x27;</span>s your name?<span class="hljs-string">&#x27;</span></span>SyntaxError: invalid syntax</code></pre><p>出现了SyntaxError（语法错误）引导的提示，这是在告诉我们这里存在错误，错误的类型就是SyntaxError，后面是对这种错误的解释“invalid syntax”（无效的语法）。<br>特别注意，错误提示错误提示会直接标注出来错误的地方，不用多说，你也能猜测出，大概在告诉我们，可能是那里出现错误了。</p><blockquote><p>在python中，这一点是非常友好的，如果语句存在错误，就会将错误输出来，供程序员改正参考。当然，错误来源有时候比较复杂，需要根据经验和知识进行修改。还有一种修改错误的好办法，就是讲错误提示放到google中搜索。</p></blockquote><p>上面那个值的错误原因是什么呢？仔细观察，发现那句话中事实上有三个单引号，本来一对单引号之间包裹的是一个字符串，现在出现了三个（一对半）单引号，computer姑娘迷茫了，她不知道单引号包裹的到底是谁。于是报错。</p><p><strong>解决方法一：</strong> 双引号包裹单引号</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; <span class="hljs-string">&quot;What&#x27;s your name?&quot;</span><span class="hljs-string">&quot;What&#x27;s your name?&quot;</span></code></pre><p>用双引号来包裹，双引号里面允许出现单引号。其实，反过来，单引号里面也可以包裹双引号。这个可以笼统地成为二者的嵌套。</p><p><strong>解决方法二：</strong> 使用转义符</p><p>所谓转义，就是让某个符号不在表示某个含义，而是表示另外一个含义。<br>转义符的作用就是它能够转变符号的含义。在python中，用\作为转义符（其实很多语言，只要有转义符的，都是用这个符号）。</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; <span class="hljs-string">&#x27;What\&#x27;s your name?&#x27;</span><span class="hljs-string">&quot;What&#x27;s your name?&quot;</span></code></pre><p>是不是看到转义符\的作用了。</p><p>本来单引号表示包括字符串，它不是字符串一部分，但是如果前面有转义符，那么它就失去了原来的含义，转化为字符串的一部分，相当于一个特殊字符了。</p><h4 id="变量和字符串"><a href="#变量和字符串" class="headerlink" title="变量和字符串"></a>变量和字符串</h4><p>前面讲过变量无类型，对象有类型了，比如在数字中:</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; a = <span class="hljs-number">5</span><span class="hljs-meta">&gt;&gt;</span>&gt; a<span class="hljs-number">5</span></code></pre><p>其本质含义是变量a相当于一个标签，贴在了对象5上面。并且我们把这个语句叫做赋值语句。</p><p>同样，在对字符串类型的对象，也是这样，能够通过赋值语句，将对象与某个标签（变量）关联起来。</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; b = <span class="hljs-string">&quot;Hello,World!&quot;</span><span class="hljs-meta">&gt;&gt;</span>&gt; b<span class="hljs-string">&#x27;Hello,World!&#x27;</span><span class="hljs-meta">&gt;&gt;</span>&gt; print(b)Hello,World!</code></pre><p>还记得我们曾经用过一个type命令吗？现在它还有用，就是检验一个变量，到底跟什么类型联系着，是字符串还是数字？</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; a = <span class="hljs-number">1</span><span class="hljs-meta">&gt;&gt;</span>&gt; b = <span class="hljs-string">&#x27;1&#x27;</span><span class="hljs-meta">&gt;&gt;</span>&gt; type(a)&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">int</span>&#x27;&gt;</span><span class="hljs-meta">&gt;&gt;</span>&gt; type(b)&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">str</span>&#x27;&gt;</span></code></pre><p>有时候，你会听到一种说法：把a称之为数字型变量，把b叫做字符（串）型变量。这种说法，在某些语言中是成立的。<br>某些语言(如Java)，需要提前声明变量，然后变量就成为了一个筐，将值装到这个筐里面。但是，python不是这样的。要注意区别。</p><h4 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h4><p>对数字，如果拼接，就是对两个数字求和。如：3+5，就计算出为8。那么对字符串都能进行什么样的操作呢？</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; <span class="hljs-string">&quot;py&quot;</span>+<span class="hljs-string">&quot;thon&quot;</span><span class="hljs-string">&#x27;python&#x27;</span></code></pre><p>两个字符串相加，就相当于把两个字符串连接起来。(别的运算就别尝试了，没什么意义，肯定报错，不信就试试）</p><pre><code class="hljs vim">&gt;&gt;&gt; <span class="hljs-string">&quot;py&quot;</span>-<span class="hljs-string">&quot;thon&quot;</span>Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):  File <span class="hljs-string">&quot;&lt;pyshell#132&gt;&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">1</span>, in <span class="hljs-symbol">&lt;module&gt;</span>    <span class="hljs-string">&quot;py&quot;</span>-<span class="hljs-string">&quot;thon&quot;</span>TypeError: unsupported operand <span class="hljs-built_in">type</span>(s) <span class="hljs-keyword">for</span> -: <span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-built_in">and</span> <span class="hljs-string">&#x27;str&#x27;</span></code></pre><p>用+号实现连接，的确比较简单，不过，有时候你会遇到这样的问题：</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; a = <span class="hljs-number">2021</span><span class="hljs-meta">&gt;&gt;</span>&gt; b = <span class="hljs-string">&quot;free&quot;</span><span class="hljs-meta">&gt;&gt;</span>&gt; a+bTraceback (most recent call last)<span class="hljs-symbol">:</span>  File <span class="hljs-string">&quot;&lt;pyshell#137&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;<span class="hljs-class"><span class="hljs-keyword">module</span>&gt;</span>    a+b<span class="hljs-symbol">TypeError:</span> unsupported operand type(s) <span class="hljs-keyword">for</span> +: <span class="hljs-string">&#x27;int&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;str&#x27;</span></code></pre><p>报错了，其错误原因已经打印出来了（一定要注意看打印出来的信息）：cannot concatenate ‘str’ and ‘int’ objects。<br>原来a对应的对象是一个int类型的，不能将它和str对象连接起来。</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; b + str(a)<span class="hljs-string">&#x27;free2021&#x27;</span></code></pre><p>用str(a)实现将整数对象转换为字符串对象。虽然str是一种对象类型，但是它也能够实现对象类型的转换，这就起到了一个函数的作用。</p><p>前面已经讲过的int也有类似的作用。比如：</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; a = <span class="hljs-string">&quot;123&quot;</span><span class="hljs-meta">&gt;&gt;</span>&gt; type(a)&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">str</span>&#x27;&gt;</span><span class="hljs-meta">&gt;&gt;</span>&gt; b = int(a)<span class="hljs-meta">&gt;&gt;</span>&gt; b<span class="hljs-number">123</span><span class="hljs-meta">&gt;&gt;</span>&gt; type(b)&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">int</span>&#x27;&gt;</span></code></pre><blockquote><p>提醒列位，如果你对int和str比较好奇，可以在交互模式中，使用help(int)，help(str)查阅相关的更多资料。</p></blockquote><p>还有第三种：</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; a = <span class="hljs-number">2021</span><span class="hljs-meta">&gt;&gt;</span>&gt; b = <span class="hljs-string">&quot;free&quot;</span><span class="hljs-meta">&gt;&gt;</span>&gt; b + repr(a)<span class="hljs-string">&#x27;free2021&#x27;</span></code></pre><p>这里repr()是一个函数，其实就是反引号的替代品，它能够把结果字符串转化为合法的python表达式。</p><p>三者之间的区别:</p><ul><li>首先明确，repr()和``是一致的。</li><li>接下来需要区别的就是repr()和str，一个最简单的区别，repr是函数，str是跟int一样，一种对象类型。</li></ul><p>不过这么说是不能完全解惑的，网上有不少人对这两者进行区分的内容，我推荐这个：</p><ol><li><p>When should i use str() and when should i use repr() ?</p><blockquote><p>Almost always use str when creating output for end users.<br>repr is mainly useful for debugging and exploring. For example, if you suspect a string has non printing characters in it, or a float has a small rounding error, repr will show you; str may not.<br>repr can also be useful for for generating literals to paste into your source code. It can also be used for persistence (with ast.literal_eval or eval), but this is rarely a good idea–if you want editable persisted values, something like JSON or YAML is much better, and if you don’t plan to edit them, use pickle.<br>译文：</p></blockquote></li><li><p>In which cases i can use either of them ?</p><blockquote><p>Well, you can use them almost anywhere. You shouldn’t generally use them except as described above.</p></blockquote></li><li><p>What can str() do which repr() can’t ?</p><blockquote><p>Give you output fit for end-user consumption–not always (e.g., str([‘spam’, ‘eggs’]) isn’t likely to be anything you want to put in a GUI), but more often than repr.</p></blockquote></li><li><p>What can repr() do which str() can’t</p><blockquote><p>Give you output that’s useful for debugging–again, not always (the default for instances of user-created classes is rarely helpful), but whenever possible.<br>And sometimes give you output that’s a valid Python literal or other expression–but you rarely want to rely on that except for interactive exploration.</p></blockquote></li></ol><h4 id="Python转义字符"><a href="#Python转义字符" class="headerlink" title="Python转义字符"></a>Python转义字符</h4><p>在字符串中，有时需要输入一些特殊的符号，但是，某些符号不能直接输出，就需要用转义符。<br>所谓转义，就是不采用符号本来的含义，而采用另外一含义了。下面表格中列出常用的转义符：</p><table><thead><tr><th>转义字符</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>(在行尾时) 续行符</td></tr><tr><td>\</td><td>反斜杠符号</td></tr><tr><td>‘</td><td>单引号</td></tr><tr><td>“</td><td>双引号</td></tr><tr><td>\a</td><td>响铃</td></tr><tr><td>\b</td><td>退格(Backspace)</td></tr><tr><td>\e</td><td>转义</td></tr><tr><td>\000</td><td>空</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\v</td><td>纵向制表符</td></tr><tr><td>\t</td><td>横向制表符</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\f</td><td>换页</td></tr><tr><td>\oyy</td><td>八进制数，yy代表的字符，例如：\o12代表换行</td></tr><tr><td>\xyy</td><td>十六进制数，yy代表的字符，例如：\x0a代表换行</td></tr><tr><td>\other</td><td>其它的字符以普通格式输出</td></tr></tbody></table><p>以上所有转义符，都可以通过交互模式下来测试一下，感受实际上是什么样子的。例如：</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; <span class="hljs-string">&quot;Hello, I am Daimon. \</span><span class="hljs-string">My Website is &#x27;https://daimonduan.top&#x27;.&quot;</span><span class="hljs-string">&quot;Hello, I am Daimon. My Website is &#x27;https://daimonduan.top&#x27;.&quot;</span><span class="hljs-meta">&gt;&gt;</span>&gt; <span class="hljs-string">&quot;you can connect me by qq\\weibo\\gmail&quot;</span><span class="hljs-string">&#x27;you can connect me by qq\\weibo\\gmail&#x27;</span></code></pre><h3 id="六、字符串-2"><a href="#六、字符串-2" class="headerlink" title="六、字符串(2)"></a>六、字符串(2)</h3><p>了解两个函数：raw_input和print</p><blockquote><p>这两个都是python的内建函数（built-in function）。关于python的内建函数，下面这个表格都列出来了。所谓内建函数，就是能够在python中直接调用，不需要做其它的操作。</p></blockquote><p><a href="https://docs.python.org/3/library/functions.html#abs">官方文档</a><br><a href="https://blog.csdn.net/qwxwaty/article/details/80384765">CSDN</a></p><table><thead><tr><th align="left"></th><th align="left"></th><th align="left">Built-in Functions</th><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">abs()</td><td align="left">dict()</td><td align="left">help()</td><td align="left">min()</td><td align="left">setattr()</td></tr><tr><td align="left">all()</td><td align="left">dir()</td><td align="left">hex()</td><td align="left">next()</td><td align="left">slice()</td></tr><tr><td align="left">any()</td><td align="left">divmod()</td><td align="left">id()</td><td align="left">object()</td><td align="left">sorted()</td></tr><tr><td align="left">ascii()</td><td align="left">enumerate()</td><td align="left">input()</td><td align="left">oct()</td><td align="left">staticmethod()</td></tr><tr><td align="left">bin()</td><td align="left">eval()</td><td align="left">int()</td><td align="left">open()</td><td align="left">str()</td></tr><tr><td align="left">bool()</td><td align="left">exec()</td><td align="left">isinstance()</td><td align="left">ord()</td><td align="left">sum()</td></tr><tr><td align="left">bytearray()</td><td align="left">filter()</td><td align="left">issubclass()</td><td align="left">pow()</td><td align="left">super()</td></tr><tr><td align="left">bytes()</td><td align="left">float()</td><td align="left">iter()</td><td align="left">print()</td><td align="left">tuple()</td></tr><tr><td align="left">callable()</td><td align="left">format()</td><td align="left">len()</td><td align="left">property()</td><td align="left">type()</td></tr><tr><td align="left">chr()</td><td align="left">frozenset()</td><td align="left">list()</td><td align="left">range()</td><td align="left">vars()</td></tr><tr><td align="left">classmethod()</td><td align="left">getattr()</td><td align="left">locals()</td><td align="left">repr()</td><td align="left">zip()</td></tr><tr><td align="left">compile()</td><td align="left">globals()</td><td align="left">map()</td><td align="left">reversed()</td><td align="left"><strong>import</strong>()</td></tr><tr><td align="left">complex()</td><td align="left">hasattr()</td><td align="left">max()</td><td align="left">round()</td><td align="left"></td></tr><tr><td align="left">delattr()</td><td align="left">hash()</td><td align="left">memoryview()</td><td align="left">set()</td><td align="left"></td></tr></tbody></table><p>以下是中文翻译：</p><div class="note note-success">            <p>一、数学运算类</p>          </div><table><thead><tr><th align="left">数学运算类</th><th align="left"></th></tr></thead><tbody><tr><td align="left">abs(x)</td><td align="left">绝对值函数</td></tr><tr><td align="left">complex([real[, imag]])</td><td align="left">复数函数</td></tr><tr><td align="left">divmod(a, b)</td><td align="left">分别为取商和取余函数</td></tr><tr><td align="left">float([x])</td><td align="left">将一个字符串或数转换为浮点数。</td></tr><tr><td align="left">int([x[, base]])</td><td align="left">将一个字符转换为整数型类型，base表示进制</td></tr><tr><td align="left">pow(x, y[, z])</td><td align="left">幂函数，返回x的y次幂</td></tr><tr><td align="left">range([start], stop[, step])</td><td align="left">产生一个序列，默认从0开始</td></tr><tr><td align="left">round(x[, n])</td><td align="left">四舍五入</td></tr><tr><td align="left">sum(iterable[, start])</td><td align="left">对集合求和</td></tr><tr><td align="left">oct(x)</td><td align="left">将一个数字转化为8进制</td></tr><tr><td align="left">hex(x)</td><td align="left">将整数x转换为16进制字符串</td></tr><tr><td align="left">chr(x)</td><td align="left">返回整数x对应的ASCII字符</td></tr><tr><td align="left">bin(x)</td><td align="left">将整数x转换为二进制字符串</td></tr><tr><td align="left">bool([x])</td><td align="left">返回一个布尔值</td></tr></tbody></table><div class="note note-success">            <p>二、集合类</p>          </div><table><thead><tr><th align="left">集合类</th><th align="left"></th></tr></thead><tbody><tr><td align="left">format(value [, format_spec])</td><td align="left">格式化输出字符串，格式化的参数顺序从0开始</td></tr><tr><td align="left">enumerate(sequence , start = 0)</td><td align="left">返回可枚举对象,该对象的next()方法将返回一个元组</td></tr><tr><td align="left">iter(o[, sentinel])</td><td align="left">生成一个对象的迭代器，第二个参数表示分隔符</td></tr><tr><td align="left">man(iterable, *[, key, default])</td><td align="left">返回集合中的最大值</td></tr><tr><td align="left">man(arg1, arg2, *args[, key])</td><td align="left">返回集合中的最大值</td></tr><tr><td align="left">min(iterable, *[, key, default])</td><td align="left">返回集合中的最小值</td></tr><tr><td align="left">min(arg1, arg2, *args[, key])</td><td align="left">返回集合中的最小值</td></tr><tr><td align="left">dict([arg])</td><td align="left">创建一个数据字典</td></tr><tr><td align="left">list([iterable])</td><td align="left">创建一个列表，元素可修改</td></tr><tr><td align="left">set()</td><td align="left">创建一个集合</td></tr><tr><td align="left">frozenset([iterable])</td><td align="left">创建一个不可变的集合</td></tr><tr><td align="left">str([object])</td><td align="left">创建一个字符串</td></tr><tr><td align="left">sorted(iterable[, cmp[, key[, reverse]]])</td><td align="left">从可迭代项返回一个新的排序列表</td></tr><tr><td align="left">tuple([iterable])</td><td align="left">创建一个元组</td></tr></tbody></table><div class="note note-success">            <p>三、逻辑判断</p>          </div><table><thead><tr><th align="left">逻辑判断</th><th align="left"></th></tr></thead><tbody><tr><td align="left">all(iterable)</td><td align="left">如果可迭代的所有元素都是true(或者如果迭代是空的),则返回1</td></tr><tr><td align="left">cmp(x, y)</td><td align="left">如果x &lt; y ,返回负数；x == y, 返回0；x &gt; y,返回正数</td></tr></tbody></table><div class="note note-success">            <p>四、反射</p>          </div><table><thead><tr><th align="left">反射</th><th align="left"></th></tr></thead><tbody><tr><td align="left">callable(object)</td><td align="left">如果对象参数看起来是可调用的,则返回True,如果不是,则返回false。如果返回true,则仍然有可能调用失败。</td></tr><tr><td align="left">compile(source, filename, mode[, flags[, dont_inherit]])</td><td align="left">将源代码编译为代码或AST对象，代码对象可以由exec()或val()执行。</td></tr><tr><td align="left">dir([object])</td><td align="left">如果没有参数,则返回当前本地范围中的名称列表。使用参数,尝试返回该对象的有效属性列表。</td></tr><tr><td align="left">delattr(object, name)</td><td align="left">删除object对象名为name的属性</td></tr><tr><td align="left">eval(expression [, globals [, locals]])</td><td align="left">计算表达式expression的值</td></tr><tr><td align="left">execfile(filename [, globals [, locals]])</td><td align="left">用法类似exec()，不同的是execfile的参数filename为文件名，而exec的参数为字符串。</td></tr><tr><td align="left">filter(function, iterable)</td><td align="left">从函数返回的可迭代元素构造迭代器。迭代可以是序列、支持迭代的容器，也可以是迭代器。如果函数为None，则假定为恒等函数，即删除所有可迭代的False元素。</td></tr><tr><td align="left">getattr(object, name [, defalut])</td><td align="left">获取一个类的属性</td></tr><tr><td align="left">globals()</td><td align="left">返回一个描述当前全局符号表的字典</td></tr><tr><td align="left">hasattr(object, name)</td><td align="left">判断对象object是否包含名为name的特性</td></tr><tr><td align="left">hash(object)</td><td align="left">如果对象object为哈希表类型，返回对象object的哈希值</td></tr><tr><td align="left">id(object)</td><td align="left">返回对象的唯一标识</td></tr><tr><td align="left">isinstance(object, classinfo)</td><td align="left">判断object是否是class的实例</td></tr><tr><td align="left">issubclass(class, classinfo)</td><td align="left">判断是否是子类</td></tr><tr><td align="left">len(s)</td><td align="left">返回集合长度</td></tr><tr><td align="left">locals()</td><td align="left">返回当前的变量列表</td></tr><tr><td align="left">map(function, iterable, …)</td><td align="left">遍历每个元素，执行function操作</td></tr><tr><td align="left">memoryview(obj)</td><td align="left">返回一个内存镜像类型的对象</td></tr><tr><td align="left">next(iterator[, default])</td><td align="left">类似于iterator.next()</td></tr><tr><td align="left">object()</td><td align="left">基类</td></tr><tr><td align="left">property([fget[, fset[, fdel[, doc]]]])</td><td align="left">属性访问的包装类，设置后可以通过c.x=value等来访问setter和getter</td></tr><tr><td align="left">reduce(function, iterable[, initializer])</td><td align="left">合并操作，从第一个开始是前两个参数，然后是前两个的结果与第三个合并进行处理，以此类推</td></tr><tr><td align="left">reload(module)</td><td align="left">重新加载模块</td></tr><tr><td align="left">setattr(object, name, value)</td><td align="left">设置属性值</td></tr><tr><td align="left">repr(object)</td><td align="left">将一个对象变幻为可打印的格式</td></tr><tr><td align="left">slice()</td><td align="left">返回表示由范围（start，stop，step）指定的一组索引的切片对象。</td></tr><tr><td align="left">staticmethod</td><td align="left">声明静态方法，是个注解</td></tr><tr><td align="left">super(type[, object-or-type])</td><td align="left">引用父类</td></tr><tr><td align="left">type(object)</td><td align="left">返回该object的类型</td></tr><tr><td align="left">vars([object])</td><td align="left">返回对象的变量，若无参数与dict()方法类似</td></tr><tr><td align="left">bytearray([source [, encoding [, errors]]])</td><td align="left">返回一个byte数组: 1、如果source为整数，则返回一个长度为source的初始化数组；2、如果source为字符串，则按照指定的encoding将字符串转换为字节序列；3、如果source为可迭代类型，则元素必须为[0 ,255]中的整数；4、如果source为与buffer接口一致的对象，则此对象也可以被用于初始化bytearray.</td></tr><tr><td align="left">zip([iterable, …])</td><td align="left">用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。</td></tr></tbody></table><div class="note note-success">            <p>五、IO操作</p>          </div><table><thead><tr><th align="left">IO操作</th><th align="left"></th></tr></thead><tbody><tr><td align="left">file(filename [, mode [, bufsize]])</td><td align="left">file类型的构造函数，作用为打开一个文件，如果文件不存在且mode为写或追加时，文件将被创建。添加‘b’到mode参数中，将对文件以二进制形式操作。添加‘+’到mode参数中，将允许对文件同时进行读写操作1、参数filename：文件名称。2、参数mode：’r’（读）、’w’（写）、’a’（追加）。3、参数bufsize：如果为0表示不进行缓冲，如果为1表示进行行缓冲，如果是一个大于1的数表示缓冲区的大小 。</td></tr><tr><td align="left">open(name[, mode[, buffering]])</td><td align="left">打开文件</td></tr><tr><td align="left">Print()</td><td align="left">打印函数</td></tr><tr><td align="left">raw_input([prompt])</td><td align="left">设置输入，输入都是作为字符串处理</td></tr></tbody></table><p>这些内建函数，怎么才能知道哪个函数怎么用，是干什么用的呢？<br>这里进行演示，这种方法是学习python的法宝:</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; help(raw_input)</code></pre><p>然后就出现：</p><pre><code class="hljs sql"><span class="hljs-keyword">Help</span> <span class="hljs-keyword">on</span> built-<span class="hljs-keyword">in</span> <span class="hljs-keyword">function</span> raw_input <span class="hljs-keyword">in</span> <span class="hljs-keyword">module</span> __builtin__:raw_input(...)    raw_input([<span class="hljs-keyword">prompt</span>]) -&gt; <span class="hljs-keyword">string</span>    <span class="hljs-keyword">Read</span> a <span class="hljs-keyword">string</span> <span class="hljs-keyword">from</span> standard input.  The trailing <span class="hljs-keyword">newline</span> <span class="hljs-keyword">is</span> stripped.    <span class="hljs-keyword">If</span> the <span class="hljs-keyword">user</span> hits EOF (Unix: Ctl-D, Windows: Ctl-Z+<span class="hljs-keyword">Return</span>), <span class="hljs-keyword">raise</span> EOFError.    <span class="hljs-keyword">On</span> Unix, GNU readline <span class="hljs-keyword">is</span> used <span class="hljs-keyword">if</span> enabled.  The <span class="hljs-keyword">prompt</span> <span class="hljs-keyword">string</span>, <span class="hljs-keyword">if</span> given,    <span class="hljs-keyword">is</span> printed <span class="hljs-keyword">without</span> a trailing <span class="hljs-keyword">newline</span> <span class="hljs-keyword">before</span> reading.</code></pre><div class="note note-danger">            <p>input()与raw_input()的区别只存在Python2.X环境下,因为在Python3中将Python2中的input()删除了,同时将raw_input()改名为input()。<br>如果你主要使用Py3，那么你只需关注在使用input()时所输入的数据最后都会输出成字符串格式，所以当你进行数字格式输入时要利用int()做好格式转换。</p>          </div><h3 id="七、字符串-3"><a href="#七、字符串-3" class="headerlink" title="七、字符串(3)"></a>七、字符串(3)</h3><p>关于字符串的内容，已经有两节进行介绍了。不过，它是一个话题中心，还要再继续。</p><p>例如这样一个字符串python，还记得前面对字符串的定义吗？它就是几个字符：p,y,t,h,o,n，排列起来。这种排列是非常严格的，不仅仅是字符本身，而且还有顺序，换言之，如果某个字符换了，就编程一个新字符串了；如果这些字符顺序发生变化了，也成为了一个新字符串。</p><p>在python中，把像字符串这样的对象类型（后面还会冒出来类似的其它有这种特点的对象类型，比如列表），统称为序列。顾名思义，序列就是“有序排列”。</p><p>比如水泊梁山的108个好汉，就是一个“有序排列”的序列。从老大宋江一直排到第108位金毛犬段景住。在这个序列中，每个人有编号，编号和每个人一一对应。1号是宋江，2号是卢俊义。反过来，通过每个人的姓名，也能找出他对应的编号。武松是多少号？14号。李逵呢？22号。</p><p>在python中，给这些编号取了一个文雅的名字，叫做索引(别的编程语言也这么称呼，不是python独有的。)。</p><h4 id="索引和切片"><a href="#索引和切片" class="headerlink" title="索引和切片"></a>索引和切片</h4><p>前面用梁山好汉的为例说明了索引。再看python中的例子：</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; lang = <span class="hljs-string">&quot;study python&quot;</span><span class="hljs-meta">&gt;&gt;</span>&gt; lang[<span class="hljs-number">0</span>]<span class="hljs-string">&#x27;s&#x27;</span><span class="hljs-meta">&gt;&gt;</span>&gt; lang[<span class="hljs-number">1</span>]<span class="hljs-string">&#x27;t&#x27;</span></code></pre><p>有一个字符串，通过赋值语句赋给了变量lang。如果要得到这个字符串的第一个单词s，可以用lang[0]。<br>当然，如果你不愿意通过赋值语句，让变量lang来指向那个字符串，也可以这样做：</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; <span class="hljs-string">&quot;study python&quot;</span>[<span class="hljs-number">0</span>]<span class="hljs-string">&#x27;s&#x27;</span></code></pre><p>效果是一样的。因为lang是标签，就指向了”study python”字符串。<br>当让python执行lang[0]的时候，就是要转到那个字符串对象，如同上面的操作一样。只不过，如果不用lang这么一个变量，后面如果再写，就费笔墨了，要每次都把那个字符串写全了。为了省事，还是复制给一个变量吧。变量就是字符串的代表了。</p><p>字符串这个序列的排序方法跟梁山好汉有点不同，第一个不是用数字1表示，而是用数字0表示。不仅仅python，其它很多语言都是从0开始排序的。<br>为什么这样做呢？这就是规定。当然，这个规定是有一定优势的。此处不展开，有兴趣的网上去搜索一下，有专门对此进行解释的文章。</p><table><thead><tr><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th><th align="center">10</th><th align="center">11</th></tr></thead><tbody><tr><td align="center">s</td><td align="center">t</td><td align="center">u</td><td align="center">d</td><td align="center">y</td><td align="center"></td><td align="center">p</td><td align="center">y</td><td align="center">t</td><td align="center">h</td><td align="center">o</td><td align="center">n</td></tr></tbody></table><p>上面的表格中，将这个字符串从第一个到最后一个进行了排序，特别注意，两个单词中间的那个空格，也占用了一个位置。</p><p>通过索引能够找到该索引所对应的字符，那么反过来，能不能通过字符，找到其在字符串中的索引值呢？怎么找？</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; lang.index(<span class="hljs-string">&quot;p&quot;</span>)<span class="hljs-number">6</span></code></pre><p>就这样，是不是已经能够和梁山好汉的例子对上号了？只不过区别在于第一个的索引值是0。</p><p>那怎么获取指定索引区间的值呢？</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; lang<span class="hljs-string">&#x27;study python&#x27;</span><span class="hljs-comment">#在前面“切”了若干的字符之后，再看一下该字符串，还是完整的。</span><span class="hljs-meta">&gt;&gt;</span>&gt; lang[<span class="hljs-number">2</span><span class="hljs-symbol">:</span><span class="hljs-number">9</span>]<span class="hljs-string">&#x27;udy pyt&#x27;</span></code></pre><p>通过lang[2:9]要得到部分（不是一个）字符，从返回的结果中可以看出，我们得到的是序号分别对应着2,3,4,5,6,7,8(跟上面的表格对应一下)字符（包括那个空格）。<br>也就是，这种获得部分字符的方法中，能够得到开始需要的以及最后一个序号之前的所对应的字符。对照上面的表格数一数就知道了。简单说就是包括开头，不包括结尾。</p><p>上述，不管是得到一个还是多个，通过索引得到字符的过程，称之为 <strong>切片</strong> 。</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; lang<span class="hljs-string">&#x27;study python&#x27;</span><span class="hljs-meta">&gt;&gt;</span>&gt; b = lang[<span class="hljs-number">1</span><span class="hljs-symbol">:</span>]    <span class="hljs-comment">#得到从1号到最末尾的字符，这时最后那个需要不用写</span><span class="hljs-meta">&gt;&gt;</span>&gt; b<span class="hljs-string">&#x27;tudy python&#x27;</span><span class="hljs-meta">&gt;&gt;</span>&gt; c = lang[<span class="hljs-symbol">:</span>]    <span class="hljs-comment">#得到所有字符</span><span class="hljs-meta">&gt;&gt;</span>&gt; c<span class="hljs-string">&#x27;study python&#x27;</span><span class="hljs-meta">&gt;&gt;</span>&gt; d = lang[<span class="hljs-symbol">:</span><span class="hljs-number">10</span>]    <span class="hljs-comment">#得到从第一个到10号之前的字符</span><span class="hljs-meta">&gt;&gt;</span>&gt; d<span class="hljs-string">&#x27;study pyth&#x27;</span></code></pre><p>在获取切片的时候，如果分号的前面或者后面的序号不写，就表示是到最末（后面的不写）或第一个（前面的不写）</p><p>lang[:10]的效果和lang[0:10]是一样的。</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; e = lang[<span class="hljs-number">0</span><span class="hljs-symbol">:</span><span class="hljs-number">10</span>]<span class="hljs-meta">&gt;&gt;</span>&gt; e<span class="hljs-string">&#x27;study pyth&#x27;</span></code></pre><p>如果分号后面有数字，所得到的切片，不包含该数字所对应的序号（前包括，后不包括）。<br>那么，是不是可以这样呢？lang[1:12]，不包括12号（事实没有12号），是不是可以得到1到11号对应的字符呢？</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; lang[<span class="hljs-number">1</span><span class="hljs-symbol">:</span><span class="hljs-number">12</span>]<span class="hljs-string">&#x27;tudy python&#x27;</span><span class="hljs-meta">&gt;&gt;</span>&gt; lang[<span class="hljs-number">1</span><span class="hljs-symbol">:</span><span class="hljs-number">13</span>]<span class="hljs-string">&#x27;tudy python&#x27;</span></code></pre><p>果然是。并且不仅仅后面写12，写13，也能得到同样的结果。但是，我这个特别要提醒，这种获得切片的做法在编程实践中是不提倡的。特别是如果后面要用到循环的时候，这样做或许在什么时候遇到麻烦。</p><p>如果在切片的时候，冒号左右都不写数字，就是前面所操作的c = lang[:]，其结果是变量c的值与原字符串一样，也就是“复制”了一份。注意，这里的“复制”我打上了引号，意思是如同复制，是不是真的复制呢？可以用下面的方式检验一下</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; c<span class="hljs-string">&#x27;study python&#x27;</span><span class="hljs-meta">&gt;&gt;</span>&gt; id(c)<span class="hljs-number">45559144</span><span class="hljs-meta">&gt;&gt;</span>&gt; id(lang)<span class="hljs-number">45559144</span></code></pre><p>id()的作用就是查看该对象在内存地址（就是在内存中的位置编号）。<br>从上面可以看出，两个的内存地址一样，说明c和lang两个变量指向的是同一个对象。<br>用c=lang[:]的方式，并没有生成一个新的字符串，而是将变量c这个标签也贴在了原来那个字符串上了。</p><h4 id="字符串基本操作"><a href="#字符串基本操作" class="headerlink" title="字符串基本操作"></a>字符串基本操作</h4><p>字符串是一种序列，所有序列都有如下基本操作：</p><ol><li>len()：求序列长度</li><li>连接2个序列</li><li>重复序列元素</li><li>in :判断元素是否存在于序列中</li><li>max() :返回最大值</li><li>min() :返回最小值</li><li>cmp(str1,str2) :比较2个序列值是否相同</li></ol><p>通过下面的例子，将这几个基本操作在字符串上的使用演示一下：</p><div class="note note-success">            <p>“+”连接字符串</p>          </div><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; str1 = <span class="hljs-string">&quot;abcd&quot;</span><span class="hljs-meta">&gt;&gt;</span>&gt; str1<span class="hljs-string">&#x27;abcd&#x27;</span><span class="hljs-meta">&gt;&gt;</span>&gt; str2 = <span class="hljs-string">&quot;abcde&quot;</span><span class="hljs-meta">&gt;&gt;</span>&gt; str2<span class="hljs-string">&#x27;abcde&#x27;</span><span class="hljs-meta">&gt;&gt;</span>&gt; str1 + str2<span class="hljs-string">&#x27;abcdabcde&#x27;</span></code></pre><p>这其实就是拼接，不过在这里，应该有一个更大的观念，我们现在只是学了字符串这一种序列，后面还会遇到列表、元组两种序列，都能够如此实现拼接。</p><div class="note note-success">            <p>in</p>          </div><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; <span class="hljs-string">&quot;a&quot;</span> in str1True<span class="hljs-meta">&gt;&gt;</span>&gt; <span class="hljs-string">&quot;de&quot;</span> in str1False<span class="hljs-meta">&gt;&gt;</span>&gt; <span class="hljs-string">&quot;de&quot;</span> in str2True</code></pre><p>in用来判断某个字符串是不是在另外一个字符串内，或者说判断某个字符串内是否包含某个字符串，如果包含，就返回True，否则返回False。</p><div class="note note-success">            <p>最值</p>          </div><pre><code class="hljs isbl">&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">max</span></span>(<span class="hljs-variable">str1</span>)</span><span class="hljs-string">&#x27;d&#x27;</span>&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">max</span></span>(<span class="hljs-variable">str2</span>)</span><span class="hljs-string">&#x27;e&#x27;</span>&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">min</span></span>(<span class="hljs-variable">str1</span>)</span><span class="hljs-string">&#x27;a&#x27;</span></code></pre><p>一个字符串中，每个字符在计算机内都是有编码的，也就是对应着一个数字，min()和max()就是根据这个数字里获得最小值和最大值，然后对应出相应的字符。<br>关于这种编号是多少，可以网上搜索(google)有关字符编码，或者ASCII编码什么的，很容易查到。</p><div class="note note-success">            <p>比较</p>          </div><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; cmp(str1, str2)-<span class="hljs-number">1</span></code></pre><p>将两个字符串进行比较，也是首先将字符串中的符号转化为对一个的数字，然后比较。如果返回的数值小于零，说明第一个小于第二个，等于0，则两个相等，大于0，第一个大于第二个。</p><p>为了能够明白其所以然，进入下面的分析：</p><pre><code class="hljs isbl">&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">ord</span></span>(<span class="hljs-string">&quot;a&quot;</span>)</span><span class="hljs-number">97</span>&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">ord</span></span>(<span class="hljs-string">&quot;b&quot;</span>)</span><span class="hljs-number">98</span>&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">ord</span></span>(<span class="hljs-string">&quot; &quot;</span>)</span><span class="hljs-number">32</span></code></pre><p>ord()是一个内建函数，能够返回某个字符（注意，是一个字符，不是多个字符组成的串）所对一个的ASCII值（是十进制的），字符a在ASCII中的值是97，空格在ASCII中也有值，是32。<br>顺便说明，反过来，根据整数值得到相应字符，可以使用chr()：</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; chr(<span class="hljs-number">97</span>)<span class="hljs-string">&#x27;a&#x27;</span></code></pre><p>于是，就得到如下比较结果了：</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; cmp(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>)    <span class="hljs-comment">#a--&gt;97, b--&gt;98, 97小于98，所以a小于b</span>-<span class="hljs-number">1</span><span class="hljs-meta">&gt;&gt;</span>&gt; cmp(<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;aaa&quot;</span>) <span class="hljs-number">1</span><span class="hljs-meta">&gt;&gt;</span>&gt; cmp(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>)<span class="hljs-number">0</span></code></pre><p>看看下面的比较，是怎么进行的呢？</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; cmp(<span class="hljs-string">&quot;ad&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>)-<span class="hljs-number">1</span></code></pre><p>在字符串的比较中，是两个字符串的第一个字符先比较，如果相等，就比较下一个，如果不相等，就返回结果。<br>直到最后，如果还相等，就返回0。位数不够时，按照没有处理（注意，没有不是0，0在ASCII中对应的是NUL），位数多的那个天然大了。<br>ad中的a先和后面的c进行比较，显然a小于c，于是就返回结果-1。</p><p>如进行下面的比较，是最容易让人迷茫的。需要根据刚才阐述来理解：</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; cmp(<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-string">&quot;23&quot;</span>)-<span class="hljs-number">1</span><span class="hljs-meta">&gt;&gt;</span>&gt; cmp(<span class="hljs-number">123</span>,<span class="hljs-number">23</span>)    <span class="hljs-comment">#也可以比较整数，这时候就是整数的直接比较了。</span><span class="hljs-number">1</span></code></pre><p><strong>注意：</strong>python3中删除了内建函数cmp：</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; cmp(str1,str2)Traceback (most recent call last)<span class="hljs-symbol">:</span>  File <span class="hljs-string">&quot;&lt;pyshell#216&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;<span class="hljs-class"><span class="hljs-keyword">module</span>&gt;</span>    cmp(str1,str2)<span class="hljs-symbol">NameError:</span> name <span class="hljs-string">&#x27;cmp&#x27;</span> is <span class="hljs-keyword">not</span> <span class="hljs-keyword">defined</span></code></pre><p>需要引入模块：</p><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-keyword">import</span> operator</span><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">operator.lt(str1,str2)</span>True</code></pre><p>此外，operator 模块封装了很多操作相关的函数, 比如 加,减 乘除 ,比较运算 ,逻辑运算 ,矩阵相乘<br>具体可以参考：<a href="https://blog.csdn.net/u010339879/article/details/98304292">python3中 operator模块用法介绍</a></p><div class="note note-success">            <p>“*”</p>          </div><p>字符串中的“乘法”，这个乘法，就是重复那个字符串的含义。在某些时候很好用的。比如我要打印一个华丽的分割线：</p><pre><code class="hljs asciidoc">&gt;&gt;&gt; str1 * 3<span class="hljs-emphasis">&#x27;abcdabcdabcd&#x27;</span>&gt;&gt;&gt; print(&quot;-&quot;<span class="hljs-strong">*20)</span><span class="hljs-strong">--------------------</span></code></pre><div class="note note-success">            <p>len()</p>          </div><p>要知道一个字符串有多少个字符，一种方法是从头开始，盯着屏幕数一数。哦，这不是计算机在干活，是键客在干活。<br>键客这样来数字符串长度：</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; a = <span class="hljs-string">&quot;hello&quot;</span><span class="hljs-meta">&gt;&gt;</span>&gt; len(a)<span class="hljs-number">5</span></code></pre><p>使用的是一个函数len(object)。得到的结果就是该字符串长度。</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; m = len(a)  <span class="hljs-comment">#把结果返回后赋值给一个变量</span><span class="hljs-meta">&gt;&gt;</span>&gt; m<span class="hljs-number">5</span><span class="hljs-meta">&gt;&gt;</span>&gt; type(m)     <span class="hljs-comment">#这个返回值（变量）是一个整数型</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">int</span>&#x27;&gt;</span></code></pre><h3 id="八、字符串-4"><a href="#八、字符串-4" class="headerlink" title="八、字符串(4)"></a>八、字符串(4)</h3><p>字符串的内容的确不少，甚至都有点啰嗦了。但是，本节依然还要继续，就是因为在编程实践中，经常会遇到有关字符串的问题，而且也是很多初学者容易迷茫的</p><h4 id="字符串格式化输出"><a href="#字符串格式化输出" class="headerlink" title="字符串格式化输出"></a>字符串格式化输出</h4><p>什么是格式化？在维基百科中有专门的词条，这么说的：</p><blockquote><p>格式化是指对磁盘或磁盘中的分区（partition）进行初始化的一种操作，这种操作通常会导致现有的磁盘或分区中所有的文件被清除。</p></blockquote><p>不知道你是否知道这种“格式化”。显然，此格式化非我们这里所说的，我们说的是字符串的格式化，或者说成“格式化字符串”，都可以，表示的意思就是：</p><blockquote><p>格式化字符串，是C、C++等程序设计语言printf类函数中用于指定输出参数的格式与相对位置的字符串参数。其中的转换说明（conversion specification）用于把随后对应的0个或多个函数参数转换为相应的格式输出；格式化字符串中转换说明以外的其它字符原样输出。</p></blockquote><p>这也是来自维基百科的定义。在这个定义中，是用C语言作为例子，并且用了其输出函数来说明。在python中，也有同样的操作和类似的函数print，此前我们已经了解一二了。</p><p>如果将那个定义说的通俗一些，字符串格式化化，就是要先制定一个模板，在这个模板中某个或者某几个地方留出空位来，然后在那些空位填上字符串。那么，那些空位，需要用一个符号来表示，这个符号通常被叫做占位符（仅仅是占据着那个位置，并不是输出的内容）。</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; <span class="hljs-string">&quot;I like %s&quot;</span><span class="hljs-string">&#x27;I like %s&#x27;</span><span class="hljs-meta">&gt;&gt;</span>&gt; <span class="hljs-string">&quot;I like %s&quot;</span> % <span class="hljs-string">&quot;python&quot;</span><span class="hljs-string">&#x27;I like python&#x27;</span><span class="hljs-meta">&gt;&gt;</span>&gt; <span class="hljs-string">&quot;I like %s&quot;</span> % <span class="hljs-string">&quot;Java&quot;</span><span class="hljs-string">&#x27;I like Java&#x27;</span></code></pre><p>这是较为常用的一种字符串输出方式。</p><p>另外，不同的占位符，会表示那个位置应该被不同类型的对象填充。下面列出许多，供参考。不过，不用记忆，常用的只有%s和%d，或者再加上%f，其它的如果需要了，到这里来查即可。</p><table><thead><tr><th align="left">占位符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">%s</td><td align="left">字符串(采用str()的显示)</td></tr><tr><td align="left">%r</td><td align="left">字符串(采用repr()的显示)</td></tr><tr><td align="left">%c</td><td align="left">单个字符</td></tr><tr><td align="left">%b</td><td align="left">二进制整数</td></tr><tr><td align="left">%d</td><td align="left">十进制整数</td></tr><tr><td align="left">%i</td><td align="left">十进制整数</td></tr><tr><td align="left">%o</td><td align="left">八进制整数</td></tr><tr><td align="left">%x</td><td align="left">十六进制整数</td></tr><tr><td align="left">%e</td><td align="left">指数 (基底写为e)</td></tr><tr><td align="left">%E</td><td align="left">指数 (基底写为E)</td></tr><tr><td align="left">%f</td><td align="left">浮点数</td></tr><tr><td align="left">%F</td><td align="left">浮点数，与上相同</td></tr><tr><td align="left">%g</td><td align="left">指数(e)或浮点数 (根据显示长度)</td></tr><tr><td align="left">%G</td><td align="left">指数(E)或浮点数 (根据显示长度)</td></tr></tbody></table><p>看例子：</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; a = <span class="hljs-string">&quot;%d years&quot;</span> % <span class="hljs-number">15</span><span class="hljs-meta">&gt;&gt;</span>&gt; a<span class="hljs-string">&#x27;15 years&#x27;</span></code></pre><p>当然，还可以在一个字符串中设置多个占位符，就像下面一样</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; a = <span class="hljs-string">&quot;China&quot;</span><span class="hljs-meta">&gt;&gt;</span>&gt; a<span class="hljs-string">&#x27;China&#x27;</span><span class="hljs-meta">&gt;&gt;</span>&gt; name = a[<span class="hljs-symbol">:</span>]<span class="hljs-meta">&gt;&gt;</span>&gt; name<span class="hljs-string">&#x27;China&#x27;</span><span class="hljs-meta">&gt;&gt;</span>&gt; age = <span class="hljs-number">5000</span><span class="hljs-meta">&gt;&gt;</span>&gt; age<span class="hljs-number">5000</span><span class="hljs-meta">&gt;&gt;</span>&gt; print(<span class="hljs-string">&quot;%s has a history of over %d years. I love %s&quot;</span> % (name, age, name))China has a history of over <span class="hljs-number">5000</span> years. I love China</code></pre><h3 id="九、字符串编码"><a href="#九、字符串编码" class="headerlink" title="九、字符串编码"></a>九、字符串编码</h3><h3 id="十、列表-1"><a href="#十、列表-1" class="headerlink" title="十、列表(1)"></a>十、列表(1)</h3><h3 id="十一、列表-2"><a href="#十一、列表-2" class="headerlink" title="十一、列表(2)"></a>十一、列表(2)</h3><h3 id="十二、列表-3"><a href="#十二、列表-3" class="headerlink" title="十二、列表(3)"></a>十二、列表(3)</h3><h3 id="十三、回顾list和str"><a href="#十三、回顾list和str" class="headerlink" title="十三、回顾list和str"></a>十三、回顾list和str</h3><h3 id="十四、元组"><a href="#十四、元组" class="headerlink" title="十四、元组"></a>十四、元组</h3><h3 id="十五、字典-1"><a href="#十五、字典-1" class="headerlink" title="十五、字典(1)"></a>十五、字典(1)</h3><h3 id="十六、字典-2"><a href="#十六、字典-2" class="headerlink" title="十六、字典(2)"></a>十六、字典(2)</h3><h3 id="十七、集合-1"><a href="#十七、集合-1" class="headerlink" title="十七、集合(1)"></a>十七、集合(1)</h3><h3 id="十八、集合-2"><a href="#十八、集合-2" class="headerlink" title="十八、集合(2)"></a>十八、集合(2)</h3>]]></content>
    
    
    <categories>
      
      <category>LearnPython</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的日期类型</title>
    <link href="/2020/12/09/DateUtil/"/>
    <url>/2020/12/09/DateUtil/</url>
    
    <content type="html"><![CDATA[<h3 id="一、调用Date的compareTo-方法来比较大小"><a href="#一、调用Date的compareTo-方法来比较大小" class="headerlink" title="一、调用Date的compareTo()方法来比较大小"></a>一、调用Date的compareTo()方法来比较大小</h3><pre><code class="hljs java">SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);Date startDate = sdf.parse(<span class="hljs-string">&quot;2020-09-02&quot;</span>);Date endDate = sdf.parse(<span class="hljs-string">&quot;2021-09-02&quot;</span>);<span class="hljs-comment">//当止期早于起期时，止期=起期</span><span class="hljs-keyword">int</span> i = endDate.compareTo(startDate);<span class="hljs-keyword">if</span>(i == -<span class="hljs-number">1</span>) &#123;System.out.println(<span class="hljs-string">&quot;止期早于起期:&quot;</span>+i);endDate = startDate;&#125;System.out.println(<span class="hljs-string">&quot;最终结果：startDate:&quot;</span>+startDate+<span class="hljs-string">&quot;||endDate&quot;</span>+endDate);</code></pre><h3 id="二、通过Date自带的before-或者after-方法比较"><a href="#二、通过Date自带的before-或者after-方法比较" class="headerlink" title="二、通过Date自带的before()或者after()方法比较"></a>二、通过Date自带的before()或者after()方法比较</h3><pre><code class="hljs java">SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);Date startDate = sdf.parse(<span class="hljs-string">&quot;2020-09-02&quot;</span>);Date endDate = sdf.parse(<span class="hljs-string">&quot;2021-09-02&quot;</span>);<span class="hljs-comment">//当止期早于起期时，止期=起期</span><span class="hljs-keyword">boolean</span> b = endDate.before(startDate);<span class="hljs-keyword">if</span>(b) &#123;System.out.println(<span class="hljs-string">&quot;止期早于起期&quot;</span>);endDate = startDate;&#125;System.out.println(b);System.out.println(<span class="hljs-string">&quot;最终结果：startDate:&quot;</span>+startDate+<span class="hljs-string">&quot;||endDate&quot;</span>+endDate);</code></pre><h3 id="三、通过SimpleDateFormat将Date转换为String"><a href="#三、通过SimpleDateFormat将Date转换为String" class="headerlink" title="三、通过SimpleDateFormat将Date转换为String"></a>三、通过SimpleDateFormat将Date转换为String</h3><pre><code class="hljs java">Date date = <span class="hljs-keyword">new</span> Date();<span class="hljs-comment">//如需时分秒则格式为：yyyy-MM-dd HH:mm:ss</span>SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);String time = sdf.format(date);System.out.println(<span class="hljs-string">&quot;当前时间:&quot;</span>+time);</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Date工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sql索引在哪些场景下会失效</title>
    <link href="/2020/11/17/SqlIndexFailure/"/>
    <url>/2020/11/17/SqlIndexFailure/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>所谓失效。并不真的就是这个索引被删除了。而是在某些情况下，DBMS不会检索索引列表了。执行速度和没有这个索引时的速度一样。<br>但是再执行另外的一条语句，同样的索引又正常起作用。所以索引的失效是针对某条sql语句，某个查询条件的，而不是针对索引本身的。</p>          </div><ol><li><p>索引字段进行判空查询时。也就是对索引字段判断是否为NULL时。语句为is null 或is not null。</p><p> <strong><em>比如：</em></strong></p> <pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> SoftWareDetailInfo <span class="hljs-keyword">where</span> CreateTime <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>;此时就不检索time字段上的索引表了。也就是索引在这条语句执行时失效了。</code></pre><p> <strong><em>接着再执行：</em></strong></p> <pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> SoftWareDetailInfo <span class="hljs-keyword">where</span> CreateTime = <span class="hljs-string">&#x27;2015-04-11 00:00:00&#x27;</span>;此时就会检索索引表了。索引又起作用了。</code></pre></li><li><p>对索引字段进行like查询时。比如：select * from SoftWareDetailInfo where SoftUseLine like ‘%OQC%’。不过网上有的例子说like ‘xx%’索引起作用。我没试过。</p></li><li><p>判断索引列是否不等于某个值时。‘!=’操作符。比如：select * from SoftWareDetailInfo where SoftUseLine != 0</p></li><li><p>对索引列进行运算。这里运算包括+-*/等运算。也包括使用函数。</p><p> <strong><em>比如：</em></strong></p> <pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> SoftWareDetailInfo <span class="hljs-keyword">where</span> SoftUseLine +<span class="hljs-number">0</span>= <span class="hljs-number">0</span>此时索引不起作用。<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> SoftWareDetailInfo <span class="hljs-keyword">where</span> <span class="hljs-keyword">count</span>(SoftUseLine) = <span class="hljs-number">0</span>此时索引也不起作用。</code></pre><p> <strong><em>也就是说如果不是直接判断索引字段列，而是判断运算或其它函数处理后的索引列索引均不起作用。</em></strong></p></li><li><p>复合索引中的前导列没有被作为查询条件。比如：Index_SoftWareDetail索引包含（a，b，c） 三列，但是查询条件里面，没有a，b 列，只有c 列，那么 Index_SoftWareDetail索引也不起作用。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LearnBoot_2.1：RESTful接口与http协议状态表述</title>
    <link href="/2020/09/22/LearnSpringBoot_2.1/"/>
    <url>/2020/09/22/LearnSpringBoot_2.1/</url>
    
    <content type="html"><![CDATA[<h3 id="一、RESTful风格API的好处"><a href="#一、RESTful风格API的好处" class="headerlink" title="一、RESTful风格API的好处"></a>一、RESTful风格API的好处</h3><p>API（Application Programming Interface），顾名思义：是一组编程接口规范，客户端与服务端通过请求响应进行数据通信。<br>REST（Representational State Transfer）表述性状态传递，决定了接口的形式与规则。<br><strong>RESTful是基于http方法的API设计风格，而不是一种新的技术.</strong></p><ol><li>看Url就知道要什么资源</li><li>看http method就知道针对资源干什么</li><li>看http status code就知道结果如何</li></ol><p>对接口开发提供了一种可以广泛适用的规范，为前端后端交互减少了接口交流的口舌成本，是约定大于配置的体现。通过下面的设计，大家来理解一下这三句话。</p><div class="note note-success">            <p>当然也不是所有的接口，都能用REST的形式来表述。<br>在实际工作中灵活运用，我们用RESTful风格的目的是为大家提供统一标准，避免不必要的沟通成本的浪费，形成一种通用的风格。<br>就好比大家都知道：伸出大拇指表示“你很棒“的意思，绝大部分人都明白，因为你了解了这种风格习惯。但是不排除有些地区伸出大拇指表示其他意思，就不适合使用！</p>          </div><h3 id="二、RESTful-API的设计风格"><a href="#二、RESTful-API的设计风格" class="headerlink" title="二、RESTful API的设计风格"></a>二、RESTful API的设计风格</h3><h4 id="2-1、RESTful是面向资源的（名词）"><a href="#2-1、RESTful是面向资源的（名词）" class="headerlink" title="2.1、RESTful是面向资源的（名词）"></a>2.1、RESTful是面向资源的（名词）</h4><p>REST 通过 URI 暴露资源时，会强调不要在 URI 中出现动词。比如：</p><table><thead><tr><th>不符合REST的接口URI</th><th>符合REST接口URI</th><th>功能</th></tr></thead><tbody><tr><td>GET /api/getDogs/{id}</td><td>GET /api/dogs/{id}</td><td>获取一个小狗</td></tr><tr><td>GET /api/getDogs</td><td>GET /api/dogs</td><td>获取所有小狗</td></tr><tr><td>GET /api/addDogs</td><td>POST /api/dogs</td><td>添加一个小狗</td></tr><tr><td>GET /api/editDogs/{id}</td><td>PUT /api/dogs/{id}</td><td>修改一个小狗</td></tr><tr><td>GET /api/deleteDogs/{id}</td><td>DELETE /api/dogs/{id}</td><td>删除一个小狗</td></tr></tbody></table><h4 id="2-2、用HTTP方法体现对资源的操作（动词）"><a href="#2-2、用HTTP方法体现对资源的操作（动词）" class="headerlink" title="2.2、用HTTP方法体现对资源的操作（动词）"></a>2.2、用HTTP方法体现对资源的操作（动词）</h4><ul><li>GET    ： 获取、读取资源</li><li>POST   ： 添加资源</li><li>PUT    ： 修改资源</li><li>DELETE ： 删除资源</li></ul><p><img src="https://img.kancloud.cn/77/8c/778c1a6b6927d9d4d1b0b038fecf0e38_955x422.png" alt="Http操作"></p><p>实际上，这四个动词实际上就对应着增删改查四个操作，这就利用了HTTP动词来表示对资源的操作。</p><h4 id="2-3-HTTP状态码"><a href="#2-3-HTTP状态码" class="headerlink" title="2.3. HTTP状态码"></a>2.3. HTTP状态码</h4><p>通过HTTP状态码体现动作的结果,不要自定义</p><pre><code class="hljs basic"><span class="hljs-symbol">200 </span>OK <span class="hljs-symbol">400 </span>Bad Request <span class="hljs-symbol">500 </span>Internal Server <span class="hljs-keyword">Error</span></code></pre><p>在 APP 与 API 的交互当中，其结果逃不出这三种状态：</p><ul><li>所有事情都按预期正确执行完毕 - 成功</li><li>APP 发生了一些错误 – 客户端错误（如：校验用户输入身份证，结果输入的是军官证，就是客户端输入错误）</li><li>API 发生了一些错误 – 服务器端错误（各种编码bug或服务内部自己导致的异常）</li></ul><p>这三种状态与上面的状态码是一一对应的。如果你觉得这三种状态，分类处理结果太宽泛，http-status code还有很多。<br>建议还是要遵循KISS(Keep It Stupid and Simple)原则，上面的三种状态码完全可以覆盖99%以上的场景。<br>这三个状态码大家都记得住，而且非常常用，多了就不一定了。</p><h4 id="2-4-Get方法和查询参数不应该改变数据"><a href="#2-4-Get方法和查询参数不应该改变数据" class="headerlink" title="2.4. Get方法和查询参数不应该改变数据"></a>2.4. Get方法和查询参数不应该改变数据</h4><p>改变数据的事交给POST、PUT、DELETE</p><h4 id="2-5-使用复数名词"><a href="#2-5-使用复数名词" class="headerlink" title="2.5. 使用复数名词"></a>2.5. 使用复数名词</h4><p>/dogs 而不是 /dog</p><h4 id="2-6-复杂资源关系的表达"><a href="#2-6-复杂资源关系的表达" class="headerlink" title="2.6. 复杂资源关系的表达"></a>2.6. 复杂资源关系的表达</h4><p>GET /cars/711/drivers/ 返回 使用过编号711汽车的所有司机<br>GET /cars/711/drivers/4 返回 使用过编号711汽车的4号司机</p><h4 id="2-7-高级用法-HATEOAS"><a href="#2-7-高级用法-HATEOAS" class="headerlink" title="2.7. 高级用法:HATEOAS"></a>2.7. 高级用法:HATEOAS</h4><p><strong>HATEOAS</strong>:Hypermedia as the Engine of Application State 超媒体作为应用状态的引擎。<br>RESTful API最好做到HATEOAS，<strong>即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</strong><br>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;link&quot;</span>: &#123;  <span class="hljs-attr">&quot;rel&quot;</span>:   <span class="hljs-string">&quot;collection https://www.example.com/zoos&quot;</span>,  <span class="hljs-attr">&quot;href&quot;</span>:  <span class="hljs-string">&quot;https://api.example.com/zoos&quot;</span>,  <span class="hljs-attr">&quot;title&quot;</span>: <span class="hljs-string">&quot;List of zoos&quot;</span>,  <span class="hljs-attr">&quot;type&quot;</span>:  <span class="hljs-string">&quot;application/vnd.yourformat+json&quot;</span>&#125;&#125;</code></pre><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API或者可以调用什么API了。</p><h4 id="2-8-资源过滤、排序、选择和分页的表述"><a href="#2-8-资源过滤、排序、选择和分页的表述" class="headerlink" title="2.8.资源过滤、排序、选择和分页的表述"></a>2.8.资源过滤、排序、选择和分页的表述</h4><table><thead><tr><th>资源功能表述</th><th>例子</th><th>详细说明</th></tr></thead><tbody><tr><td>资源数据过滤</td><td>GET /cars?color=red</td><td>获取红色的汽车</td></tr><tr><td>资源数据过滤</td><td>GET /cars?seats&lt;=4</td><td>获取小于四座位的汽车</td></tr><tr><td>资源数据排序</td><td>GET /cars?sort=-manufactorer,+model</td><td>获取汽车资源数据，先按照生产者降序排序、再按照车架模型升序排序</td></tr><tr><td>资源数据字段选择</td><td>GET /cars?fields=manufactorer,model,id,color</td><td>只选取其中一些字段，给API消费者一个选择字段的能力，这会降低网络流量</td></tr><tr><td>资源数据分页</td><td>GET /cars?offset=10&amp;limit=5</td><td>使用limit和offset，实现分页、缺省</td></tr></tbody></table><h4 id="2-9-版本化你的API"><a href="#2-9-版本化你的API" class="headerlink" title="2.9. 版本化你的API"></a>2.9. 版本化你的API</h4><p>强制性增加API版本声明，不要发布无版本的API。如：/api/v1/blog<br><strong>面向扩展开放，面向修改关闭</strong>：也就是说一个版本的接口开发完成测试上线之后，我们一般不会对接口进行修改，如果有新的需求就开发新的接口进行功能扩展。<br>这样做的目的是：当你的新接口上线后，不会影响使用老接口的用户。如果新接口目的是替换老接口，也不要在v1版本原接口上修改，而是开发v2版本接口，并声明v1接口废弃！</p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p>关于HTTP RESTful风格API设计的更多例子，请大家参考：<a href="http://httpbin.org/">http://httpbin.org/</a></p>]]></content>
    
    
    <categories>
      
      <category>LearnBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LearnBoot_1.5：IDEA环境下的热加载与热部署</title>
    <link href="/2020/09/22/LearnSpringBoot_1.5/"/>
    <url>/2020/09/22/LearnSpringBoot_1.5/</url>
    
    <content type="html"><![CDATA[<p>在实际的开发过程中，我们经常修改代码之后，手动的重启项目，手动刷新浏览器查看修改效果。<br>那么有没有一种方式能够快速的、自动的帮我们将修改代码自动更新，避免手动重启，从而提高开发效率呢？<br>肯定是有的，但是对于这个功能很多人对功能的叫法有争议，笔者查询了维基百科、官方文档，没有得到合理的答案，也没有权威的定义。<br>笔者知道的就有：热启动、热加载、热更新、热部署、热切换。<br>这几个词从语义上是有区别的，但是叫什么并不重要，实现了最重要，毕竟绝大部分程序员为了使用这个功能方便开发，也不是专业的搞学术研究的。</p><div class="note note-success">            <p>如果哪位朋友获得了权威渠道的说法，可以将文档连接反馈给我。我再理解一下，争取做到学术研究级别的一丝不苟！在此之前笔者按照自己的想法和英文翻译的角度去使用这些名词。</p>          </div><h3 id="一、使用Jrebel插件"><a href="#一、使用Jrebel插件" class="headerlink" title="一、使用Jrebel插件"></a>一、使用Jrebel插件</h3><p>这是最简单的一种方式，但是有一定的个局限性，Jrebel插件是收费的。虽然有破解方案，但是不建议！有需要的同学自行研究，这里就不多做介绍了。</p><div class="note note-warning">            <p>Jrebel插件在有些Spring Boot版本不够兼容，会报错，越新的版本越容易报错。所以笔者目前还是选择性放弃使用该方法！</p>          </div><p>第一步：安装插件，按照箭头所示选择安装。安装完成之后，要重启IDEA才能生效。<br><img src="https://img.kancloud.cn/b5/86/b5862bc7e81a1d84ea614bf8763feb72_1533x885.png" alt="安装插件"></p><p>第二步：激活。在安装完成之后，右上角会多出这样几个按钮。<br>点击之后会提示你进行插件激活，可以注册码激活，也可以在线激活。也可以填写个人姓名、邮箱、电话之后获取10天的试用！<br><img src="https://img.kancloud.cn/eb/46/eb46dbc880b3b57d634b8a82dfdc65dc_623x225.png" alt="激活"></p><p>第三步：更新操作触发配置，这个配置不仅结合Jrebel使用有效，对于其他的方式实现开发过程中需要自动更新的情况下，也要勾选上。<br><img src="https://img.kancloud.cn/b6/39/b63998ed48839cf7e05346dcc4e15385_497x277.png" alt="更新操作触发配置"></p><p>在Spring Boot项目启动配置中，选择下图中的红色框中的内容：uodate classes and resources on ‘update’ action<br><img src="https://img.kancloud.cn/c1/fd/c1fd71a6e07c941652d4fc3e9b7304b6_1429x863.png" alt="启动配置"><br>配置完成后，通过右上角的JR按钮启动SpringBoot项目。就可以实现改动代码和资源的自动更新。</p><h3 id="二、devtools实现热加载"><a href="#二、devtools实现热加载" class="headerlink" title="二、devtools实现热加载"></a>二、devtools实现热加载</h3><p>这是一种对于SpringBoot而言比较常见的一种实现方式。</p><h4 id="2-1-引入devtools的maven依赖"><a href="#2-1-引入devtools的maven依赖" class="headerlink" title="2.1.引入devtools的maven依赖"></a>2.1.引入devtools的maven依赖</h4><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- devtools --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>spring-boot-devtools从名称就可以看出来，是开发者工具包，其主要的功能就是实现热加载。<br><img src="https://img.kancloud.cn/38/a0/38a0bd94ef6dea1c12046e0f51a16c31_1069x412.png" alt="devtools"><br>其实现原理就是两个ClassLoader<br>一个负责加载那些不会经常改变的文件，比如：第三方jar包，一旦引入项目之后这部分代码在调试过程中就处于不变的状态；<br>一个负责加载可能经常改变的类，比如我们自己在项目中写的代码，被称为restart ClassLoader。<br>当有代码发生改变的时候，重建一个restart ClassLoader，原有的restart ClassLoader被丢掉。由于每次重新加载的内容较少，所以速度比手动重启更快一些。</p><h4 id="2-2-设置IDEA"><a href="#2-2-设置IDEA" class="headerlink" title="2.2.设置IDEA"></a>2.2.设置IDEA</h4><p>首先，运行时编译配置：组合键：“Shift+Ctrl+Alt+/” ，选择 “Registry” ，选中打勾 “compiler.automake.allow.when.app.running” 。<br><img src="https://box.kancloud.cn/974e40a4165195960c5a4a888cbb78e3_1069x322.png" alt="运行时编译"></p><p>其次，自动化编译配置： “File” -&gt; “Settings” -&gt; “Build,Execution,Deplyment” -&gt; “Compiler”，选中打勾 “Make project automatically” 。<br>这是一种重新自动化的编译整体项目的方法。但是笔者一般不这么做，因为IDEA的文件是自动保存的，你想修改一个字符串，<br>有可能你只修改完成第一个字符它就重新编译了，重新加载启动。<br><strong>所以，笔者一般代码修改完成之后，使用Ctrl + F9快捷键对修改类重新编译，而不是做项目的自动化编译。</strong><br><img src="https://img.kancloud.cn/54/b4/54b4462c8b4a3314e4eeb557862e7837_716x424.png" alt="自动化编译配置"></p><p>最后，在一些相对旧的IDEA版本上运行时配置，按如下图形勾选。（新版本IDEA已经不需要了）<br><img src="https://img.kancloud.cn/aa/50/aa50626eecc8c3aebe857f21ad53df2d_688x482.png" alt="旧版本运行时配置"></p><h4 id="2-3-修改一下application-properties配置"><a href="#2-3-修改一下application-properties配置" class="headerlink" title="2.3.修改一下application.properties配置"></a>2.3.修改一下application.properties配置</h4><p>在比较新的Spring Boot devtools版本中我们已经不需要做如下的配置了，但是如果你以上的步骤都完成了，仍然无法实现代码更改之后的热加载，请参考下面的方法。<br>在有些版本我们需要配置热加载生效的开关，使其值等于true。</p><p><strong>下文是properties格式配置，喜欢yml格式的同学可以自行调整一下。</strong><br>默认情况下，支持热加载的目录如下，如果需要其它目录下文件支持热加载需要手动配置：</p><ul><li>/META-INF/maven</li><li>/META-INF/resources</li><li>/resources</li><li>/static</li><li>/public</li><li>/templates</li></ul><pre><code class="hljs yml"><span class="hljs-comment">#热加载生效</span><span class="hljs-string">spring.devtools.restart.enabled=true</span><span class="hljs-comment">#额外新增的热加载目录</span><span class="hljs-string">spring.devtools.restart.additional-paths=</span> <span class="hljs-string">src/main/java</span><span class="hljs-comment">#热加载排除目录</span><span class="hljs-comment">#spring.devtools.restart.exclude= </span></code></pre><h4 id="2-4-LiveReload插件"><a href="#2-4-LiveReload插件" class="headerlink" title="2.4.LiveReload插件"></a>2.4.LiveReload插件</h4><p>最后建议你去chrome 浏览器插件商店安装一个插件叫做LiveReload。<br><img src="https://img.kancloud.cn/bd/91/bd91e4e886709035cba31d16978657c3_2405x798.gif" alt="LiveReload插件"></p><p>Spring devtools默认会启动一个 Live Reload Server实例。<br>监听文件的变化，并实时的与浏览器插件通信，更新浏览器展示界面。<br>这样，你就不用每次更改内容之后都点击浏览器刷新按钮了。</p><h4 id="2-5-最后测试一下"><a href="#2-5-最后测试一下" class="headerlink" title="2.5.最后测试一下"></a>2.5.最后测试一下</h4><p>改一下代码，看看会不会生效。通常不生效的原因有两种：</p><ul><li>JDK编译版本和运行版本不统一，自行学习一下IDEA环境下JDK配置</li><li>浏览器缓存或者其他的缓存软件导致的问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>LearnBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LearnBoot_1.4：提高开发效率必备工具lombok</title>
    <link href="/2020/09/22/LearnSpringBoot_1.4/"/>
    <url>/2020/09/22/LearnSpringBoot_1.4/</url>
    
    <content type="html"><![CDATA[<h3 id="一、使用lombok插件的好处"><a href="#一、使用lombok插件的好处" class="headerlink" title="一、使用lombok插件的好处"></a>一、使用lombok插件的好处</h3><p>我们在java开发过程中，经常会有一些常规性的，重复性的工作。比如：</p><ul><li>根据成员变量生成get和set方法</li><li>根据成员变量生成类的构造函数</li><li>重写toString()和hashCode方法</li><li>引入日志框架logFactory，用来打印日志<br>以上都是一些重复动作，模板代码。每次都手动生成既浪费时间，又增加了大量的冗余代码。<br>我们可以使用lombok插件来解决这个问题。使我们的编码效率得到大幅度的提高！</li></ul><h3 id="二、如何安装lombok插件"><a href="#二、如何安装lombok插件" class="headerlink" title="二、如何安装lombok插件"></a>二、如何安装lombok插件</h3><p>笔者以InelliJ IDEA为例，安装lombok插件。<br>打开 IDEA 的 File-&gt;Settings 面板，并选择 Plugins 选项，然后点击 “Browse repositories”。<br>在搜索框输入”lombok”，结果中找到lombok点击install，然后重启 IDEA。<br><img src="https://img.kancloud.cn/45/d4/45d483570ca6807eae7de5e6c3ab3cd6_762x511.png" alt="install Lombok"></p><p>我们还要在pom.xml里面加上如下依赖，插件生效。</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- lombok --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><div class="note note-success">            <p>在Spring Boot项目里面不需要加入版本号，spring Boot父项目会代为管理。如果是其他项目，请自行添加版本号！</p>          </div><h3 id="三、使用lombok注解简化开发"><a href="#三、使用lombok注解简化开发" class="headerlink" title="三、使用lombok注解简化开发"></a>三、使用lombok注解简化开发</h3><h4 id="3-1-Data注解"><a href="#3-1-Data注解" class="headerlink" title="3.1.Data注解"></a>3.1.Data注解</h4><p>在java类上使用@Data注解，将为我们在编译期自动生成</p><ul><li>成员变量的get和set方法</li><li>equals方法</li><li>canEqual方法</li><li>hashCode方法</li><li>toString方法</li></ul><p><img src="https://img.kancloud.cn/ab/0a/ab0a2c82558587327f06cca3f094d964_763x473.png" alt="Data注解"></p><p>上图左侧是使用lombok注解Data，右侧是java字节码class文件反编译结果</p><h4 id="3-2-Slf4j注解"><a href="#3-2-Slf4j注解" class="headerlink" title="3.2.Slf4j注解"></a>3.2.Slf4j注解</h4><p>此注解将在编译期自动帮我们引入Logger日志常量，我们在代码中就直接使用log.info或log.debug打印日志即可。下图中红色代码就用Slf4j注解代替就可以了。</p><p><img src="https://img.kancloud.cn/d2/4f/d24f55de1112606f804e9bf6280b3be0_750x441.png" alt="Slf4j注解"></p><h4 id="3-3-Builder注解"><a href="#3-3-Builder注解" class="headerlink" title="3.3.Builder注解"></a>3.3.Builder注解</h4><p>在Java类上使用Builder注解之后，我们可以使用如下代码为对象属性赋值</p><pre><code class="hljs java">LombokPOJO lombokPOJO = LombokPOJO.builder()        .name(<span class="hljs-string">&quot;kobe&quot;</span>)        .age(<span class="hljs-number">39</span>)        .build();</code></pre><p><img src="https://img.kancloud.cn/bd/a3/bda328a18d6acb36be7a3673f2f4122c_1384x862.png" alt="Builder注解"></p><h4 id="3-4-AllArgsConstructor注解"><a href="#3-4-AllArgsConstructor注解" class="headerlink" title="3.4.AllArgsConstructor注解"></a>3.4.AllArgsConstructor注解</h4><p>AllArgsConstructor注解将为我们在编译期自动生成：全参构造函数。</p><p><img src="https://img.kancloud.cn/f9/4f/f94f6763804e87144618e7c9cde0fd5a_1202x466.png" alt="AllArgsConstructor注解"></p><p>有全参构造函数注解，自然就有无参构造函数注解：NoArgsConstructor注解。</p>]]></content>
    
    
    <categories>
      
      <category>LearnBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>lombok</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LearnBoot_1.3：需要先了解的核心概念</title>
    <link href="/2020/09/22/LearnSpringBoot_1.3/"/>
    <url>/2020/09/22/LearnSpringBoot_1.3/</url>
    
    <content type="html"><![CDATA[<h3 id="一、Spring、SpringMVC、SpringBoot对比"><a href="#一、Spring、SpringMVC、SpringBoot对比" class="headerlink" title="一、Spring、SpringMVC、SpringBoot对比"></a>一、Spring、SpringMVC、SpringBoot对比</h3><p>SpringBoot项目目的并不是替换Spring、SpringMVC，而是使他们用起来更加简单。<br><strong>Spring</strong><br>Spring框架最核心的特性就是依赖注入DI（Dependency Injecttion）和控制反转IOC（Inversion Of Control）。如果能够合理的使用DI和IOC，可以开发出松耦合、扩展性好的的应用程序。</p><p><strong>SpringMVC</strong><br>Spring MVC提供了一种友好的方式来开发Web应用程序。 通过使用诸如Dispatcher Servlet，ModelAndView和View Resolver，可以轻松开发Web应用程序。</p><p><strong>SpringBoot</strong><br>Spring 和 Spring MVC最大的弊病在于存在大量的配置，并且这些配置在不同的项目中具有很高的相似性。从而导致重复配置，繁琐而且杂乱！<br>Spring Boot期望通过结合自动配置和starters来解决了这个问题。 另外，Spring Boot还提供了一些功能，可以更快地构建可用于生产环境的应用程序。</p><h3 id="二、Spring-Boot-自动配置"><a href="#二、Spring-Boot-自动配置" class="headerlink" title="二、Spring Boot 自动配置"></a>二、Spring Boot 自动配置</h3><p>Spring和Spring MVC应用程序里面有大量的XML或Java Bean配置。Spring Boot为解决这个问题，提供一种新的解决方案，新的思维方式。<br><img src="https://img.kancloud.cn/e0/f3/e0f386d1c8916f4926946d42bf151337_956x578.png" alt="自动配置"><br>SpringBoot思考的方式：是不是可以更加智能一点，当Spring中加入一些新的jar包，加入一些配置，可以自动的影响应用内的bean的加载。 比如：Spring MVC JAR位于类路径中时，自动配置Dispatcher Servlet。当然，当这些自动的默认配置不符合我们的要求的时候，我们可以修改。修改之前加载的这一些Bean，配置修改之后会自动加载另外一些Bean。</p><h3 id="三、什么是Spring-Boot-Starter？"><a href="#三、什么是Spring-Boot-Starter？" class="headerlink" title="三、什么是Spring Boot Starter？"></a>三、什么是Spring Boot Starter？</h3><p>Spring Boot Starter是一组被依赖第三方类库的集合。<br>如果你要开发一个web应用程序，就通过包管理工具(如maven)引入spring-boot-starter-web就可以了，而不用分别引入下面这么多依赖类库，<br>spring-boot-starter-web一次性帮你引入下面的这些常用类库。</p><ul><li>Spring — spring 核心, beans, context上下文, AOP面向切面</li><li>Web MVC — Spring MVC</li><li>Jackson — JSON数据的序列化与反序列化</li><li>Validation — Hibernate参数校验及校验API</li><li>嵌入式 Servlet Container — Tomcat</li><li>日志框架Logging — logback, slf4j</li></ul><p><img src="https://img.kancloud.cn/17/c6/17c6abe1c379cb541484b6844e6b4093_603x545.png" alt="SpringBootStarter"></p><h3 id="四、什么是Spring-Boot-Starter-Parent"><a href="#四、什么是Spring-Boot-Starter-Parent" class="headerlink" title="四、什么是Spring Boot Starter Parent"></a>四、什么是Spring Boot Starter Parent</h3><p>所有的Spring Boot项目默认使用spring-boot-starter-parent作为应用程序的父项目。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre><p>继承父项目的好处在于： 统一java版本配置和其他的一些依赖类库的版本。<br>也就是说，你引入的第三方类库不要加版本号，父项目替你管理版本，而且是经过兼容性测试的。比你自己随便引入一个版本兼容性更好。</p><div class="note note-success">            <p>当然父项目只能帮你管理一些常用类库的版本，如果你引入一些不常用的jar，还是要自己管理版本号及兼容性！</p>          </div><h3 id="五、嵌入式web容器"><a href="#五、嵌入式web容器" class="headerlink" title="五、嵌入式web容器"></a>五、嵌入式web容器</h3><p>Spring boot打成jar包，默认包含嵌入式的web容器：tomcat。你可以简单的使用如下命令启动一个web服务：</p><pre><code class="hljs sh">java -jar springboot-demo.jar</code></pre><p>这更有利于微服务的部署及微服务的构建、启动、扩容。Spring Boot还支持Jetty和Undertow作为web容器。</p><h3 id="六、Spring-Data"><a href="#六、Spring-Data" class="headerlink" title="六、Spring Data"></a>六、Spring Data</h3><p><img src="https://img.kancloud.cn/71/5b/715bd18bdaf7ca530da4857c8da14881_591x305.png" alt="SpringData"></p><p>Spring Data的目标是提供一种更友好的方式或者是API来存取数据。包括对于关系型数据库和NOSQL数据的支持。比如：</p><ul><li>Spring Data JPA — 关系型数据库操作的API，友好且易于使用</li><li>Spring Data MongoDB -MongoDB的操作API</li><li>Spring Data REST — 从持久层Repositories自动生成服务层API，暴露 REST APIs 接口。超级好用！</li></ul><p>当然，Spring Data还有更多好用的特性和支持等待你去探索！</p><h3 id="七、spring-boot2-x新特性"><a href="#七、spring-boot2-x新特性" class="headerlink" title="七、spring boot2.x新特性"></a>七、spring boot2.x新特性</h3><h4 id="7-1-基础环境升级"><a href="#7-1-基础环境升级" class="headerlink" title="7.1.基础环境升级"></a>7.1.基础环境升级</h4><ul><li>最低 JDK 8，支持 JDK 9，不再支持 Java 6 和 7。Spring Boot 2.0 要求 Java 8 作为最低版本，许多现有的 API 已更新，以利用 Java 8 的特性。<br>例如，接口上的默认方法，函数回调以及新的 API，如 javax.time。</li><li>如果你正在使用 Java 7 或更早版本，则在开发 Spring Boot 2.0 应用程序之前，需要升级你的 JDK。<h4 id="7-2-依赖组件升级"><a href="#7-2-依赖组件升级" class="headerlink" title="7.2.依赖组件升级"></a>7.2.依赖组件升级</h4></li><li>Jetty 9.4，Jetty 是一个开源的 Servlet 容器，它为基于 Java 的 Web 内容，例如 JSP 和 Servlet 提供运行环境。Jetty 是使用 Java 语言编写的，它的 API 以一组 JAR 包的形式发布。</li><li>Tomcat 8.5，Apache Tomcat 8.5.x 旨在取代 8.0.x，完全支持 Java 9。</li><li>Flyway 5，Flyway 是独立于数据库的应用、管理并跟踪数据库变更的数据库版本管理工具。用通俗的话讲，Flyway 可以像 SVN 管理不同人的代码那样，管理不同人的 SQL 脚本，从而做到数据库同步。</li><li>Hibernate 5.2，Hibernate 是一款非常流行的 ORM 框架。</li><li>Gradle 3.4，Spring Boot 的 Gradle 插件在很大程度上已被重写，有了重大的改进。</li><li>Thymeleaf 3.0，Thymeleaf 3 相对于 Thymeleaf 2 有非常大的性能提升。<h4 id="7-3-默认软件替换"><a href="#7-3-默认软件替换" class="headerlink" title="7.3. 默认软件替换"></a>7.3. 默认软件替换</h4></li><li>默认数据库连接池已从 Tomcat 切换到 HikariCP，HikariCP 是一个高性能的 JDBC 连接池，Hikari 是日语“光”的意思。</li><li>redis客户端默认使用 Lettuce，替换掉Jedis.Lettuce 是一个可伸缩的线程安全的 Redis 客户端，用于同步、异步和反应使用。多个线程可以共享同一个 RedisConnection，它利用优秀 Netty NIO 框架来高效地管理多个连接，支持先进的 Redis 功能，如 Sentinel、集群、流水线、自动重新连接和 Redis 数据模型。<h4 id="7-4-新技术的引入"><a href="#7-4-新技术的引入" class="headerlink" title="7.4.新技术的引入"></a>7.4.新技术的引入</h4></li><li>响应式编程WebFlux,重要的变革</li><li>支持 Quartz,Spring Boot 1.0 并没有提供对 Quartz 的支持，之前出现了各种集成方案，Spring Boot 2.0 给出了最简单的集成方式。</li><li>对Kotlin 的支持</li><li>JOOQ 的支持,JOOQ 是基于 Java 访问关系型数据库的工具包。JOOQ 既吸取了传统 ORM 操作数据的简单性和安全性，又保留了原生 SQL 的灵活性，它更像是介于 ORMS 和 JDBC 的中间层。<h4 id="7-5-彩蛋"><a href="#7-5-彩蛋" class="headerlink" title="7.5.彩蛋"></a>7.5.彩蛋</h4></li></ul><p><strong>在 Spring Boot 1.0 项目中 src/main/resources 路径下新建一个 banner.txt 文件：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;文件中写入一些字符，启动项目时就会发现默认的 Banner 被替换了。<br><strong>到了 Spring Boot 2.0 现在可以支持 Gif 文件的打印：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot 2.0 在项目启动的时候，会将 Gif 图片的每一个画面，按照顺序打印在日志中，所有的画面打印完毕后，才会启动 Spring Boot 项目。</p>]]></content>
    
    
    <categories>
      
      <category>LearnBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LearnBoot_1.2：使用IntellijIDEA建立第一个springBoot项目</title>
    <link href="/2020/09/22/LearnSpringBoot_1.2/"/>
    <url>/2020/09/22/LearnSpringBoot_1.2/</url>
    
    <content type="html"><![CDATA[<h3 id="一、使用Maven搭建SpringBoot项目"><a href="#一、使用Maven搭建SpringBoot项目" class="headerlink" title="一、使用Maven搭建SpringBoot项目"></a>一、使用Maven搭建SpringBoot项目</h3><p>由于部分网络原因，没有办法通过Spring Assistant生成SpringBoot项目，故通过新建Maven项目手动配置pom.xml的方式建立项目</p><ol><li>设定groupId等<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.daimon<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>HelloWorld<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>master<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></code></pre></li><li>选取父项目spring-boot-starter-parent，此处使用SpringBoot2.1版本<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre></li><li>SpringBoot默认内嵌的servlet服务器是tomcat，我这里选取undertow替换掉tomcat<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 启动类,去除tomcat --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- undertow --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li>在resources目录新建application.yml配置文件<pre><code class="hljs yml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span></code></pre><h3 id="二、Hello-World示例程序"><a href="#二、Hello-World示例程序" class="headerlink" title="二、Hello World示例程序"></a>二、Hello World示例程序</h3>若使用的Spring Assistant生成SpringBoot项目，可以将application.properties改成application.yml。yml文件和properties配置文件具有同样的功能。二者的区别在于：</li></ol><ul><li>yml文件的层级更加清晰直观，但是书写时需要注意格式缩进对齐。yml格式配置文件更有利于表达复杂数据结构的配置。比如：列表，对象。</li><li>properties阅读上不如yml直观，好处在于书写时不用特别注意格式缩进对齐。</li></ul><ol><li>在com.daimon根路径下新建Application启动类<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.daimon;<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Daimon</span><span class="hljs-comment"> * <span class="hljs-doctag">@Title</span>: HelloWorldApplication</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: TODO</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/9/2215:06</span><span class="hljs-comment"> */</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(HelloWorldApplication.class, args);    &#125;&#125;</code></pre></li><li>一个hello world测试Controller<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.daimon.controller;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Daimon</span><span class="hljs-comment"> * <span class="hljs-doctag">@Title</span>: HelloController</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: TODO</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/9/2215:20</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;    &#125;&#125;</code></pre></li><li>运行HelloWorldApplication，访问<a href="http://localhost:8081/hello%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%A7%81%E5%88%B0%E9%A1%B5%E9%9D%A2%E8%BE%93%E5%87%BA%E5%86%85%E5%AE%B9%E2%80%9Chello">http://localhost:8081/hello，可以见到页面输出内容“hello</a> world”<br>至此，运行成功~<h3 id="三、项目结构目录结构简介"><a href="#三、项目结构目录结构简介" class="headerlink" title="三、项目结构目录结构简介"></a>三、项目结构目录结构简介</h3>项目结构目录整体上符合maven规范要求：<table><thead><tr><th>目录位置</th><th>功能</th></tr></thead><tbody><tr><td>src/main/java</td><td>项目java文件存放位置，初始化包含主程序入口 XxxApplication，可以通过直接运行该类来 启动 Spring Boot应用</td></tr><tr><td>src/main/resources</td><td>存放静态资源，图片、CSS、JavaScript、web页面模板文件等</td></tr><tr><td>src/test</td><td>单元测试代码目录</td></tr><tr><td>target文件夹</td><td>项目代码构建打包结果文件存放位置，不需要人为维护</td></tr><tr><td>pom.xml</td><td>maven项目配置文件</td></tr><tr><td>application.properties（application.yml）</td><td>用于存放程序的各种依赖模块的配置信息，比如服务端口，数据库连接配置等</td></tr></tbody></table></li></ol><ul><li>src/main/resources/static主要用来存放css、图片、js等开发用静态文件</li><li>src/main/resources/public用来存放可以直接用于访问的html文件</li><li>src/main/resources/templates用来存放web开发模板文件</li></ul>]]></content>
    
    
    <categories>
      
      <category>LearnBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LearnBoot_1.1：SpringBoot产生背景及优势</title>
    <link href="/2020/09/22/LearnSpringBoot_1.1/"/>
    <url>/2020/09/22/LearnSpringBoot_1.1/</url>
    
    <content type="html"><![CDATA[<h3 id="一、SpringBoot的诞生背景"><a href="#一、SpringBoot的诞生背景" class="headerlink" title="一、SpringBoot的诞生背景"></a>一、SpringBoot的诞生背景</h3><ul><li>随着web项目集成软件的不断增多，xml配置也不断的增多，xml配置文件也在不断地增多，项目的依赖管理也越发的复杂。spring框架也因此饱受争议，配置文件难以理解且容易出错。</li><li>xml配置文件不但复杂，而且绝大部分属于模板配置，也就是说有80%以上的配置是不断重复的。在这个web项目里面这样配置，挪到另一个项目里面这部分配置仍然相同</li></ul><p>因此，像JFinal这种轻量级的web开发框架，因为其简单易用的特性，而逐渐的有了很大发展的空间。Spring社区也逐渐意识到了这个问题，在 2013 年的 SpringOne 2GX 会议上，Pivotal 的 CTO Adrian Colyer 回应了关于spring框架使用复杂度的问题，并且特别提到该平台将来的目标之一就是实现免 XML 配置和提供更佳开发体验。也就是我们今天使用到的spring boot的诞生的主要原因。</p><div class="note note-success">            <p>Spring 开源社区背后有强大的商业公司支持，目前已知的支持力度比较大的公司就是Pivotal 、netflix以及中国的阿里巴巴。</p>          </div><h3 id="二、SpringBoot改变了什么"><a href="#二、SpringBoot改变了什么" class="headerlink" title="二、SpringBoot改变了什么"></a>二、SpringBoot改变了什么</h3><p><strong>举一个例子:自己接电线与标准化插座</strong><br>Spring Boot的配置方式，就像是插头插座，就是这个标准。你第三方开源类库想接入进来，你就按照这个标准做一个starter的适配。<br>spring MVC方式就像是手动接电线，很灵活，但是不同的人接出来的效果千差万别，而且很容易出错。<br>Spring boot虽然灵活性不如Spring MVC的方式，并且你也不太清楚插座里面的线路是什么样，但就是方便易用。</p><p>Spring Boot 的目标不在于为已解决的问题领域提供新的解决方案，而是为平台带来另一种新的开发体验，从而简化对这些已有技术的使用。</p><ul><li>使配置变简单</li><li>使监控变简单</li><li>使部署变简单</li><li>使开发变简单</li></ul><h3 id="三、SpringBoot主要特性"><a href="#三、SpringBoot主要特性" class="headerlink" title="三、SpringBoot主要特性"></a>三、SpringBoot主要特性</h3><ul><li>遵循“约定优于配置”的原则，简化配置</li><li>可以完全脱离XML配置文件,采用注解配置和java Config</li><li>内嵌Servlet容器，应用可用jar包执行：java -jar</li><li>快速完成项目搭建、整合第三方类库，方便易用</li><li>提供了starter POM, 能够非常方便的进行包管理, 简化包管理配置</li><li>与Spring cloud天然集成，spring boot是目前java体系内实现微服务最佳方案</li></ul><h3 id="四、SpringBoot集成第三方类库的步骤"><a href="#四、SpringBoot集成第三方类库的步骤" class="headerlink" title="四、SpringBoot集成第三方类库的步骤"></a>四、SpringBoot集成第三方类库的步骤</h3><ol><li>通过maven引入springboot-XXXX-starter</li><li>修改ymal或properties全局统一配置文件</li><li>加入一个Java Config。这个属于个性化配置，如果使用通用配置，这一步不需要。<br>有哪些官方已经默认集成的类库？请参考：<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter">https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>LearnBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo使用手册</title>
    <link href="/2020/09/18/HexoUserManual/"/>
    <url>/2020/09/18/HexoUserManual/</url>
    
    <content type="html"><![CDATA[<h4 id="主题-amp-快速开始"><a href="#主题-amp-快速开始" class="headerlink" title="主题&amp;快速开始"></a>主题&amp;快速开始</h4><p>选取了<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a>作为博客主题，轻量、快速、美观、功能齐全。</p><ul><li><a href="https://hexo.fluid-dev.com/docs/start/">官方使用指南</a></li><li><a href="https://hexo.fluid-dev.com/docs/guide/">主题操作示例</a></li><li>项目从零搭建教程参考：<a href="https://www.cnblogs.com/visugar/p/6821777.html">hexo从零开始到搭建完整</a></li><li>gitBase设置SSH连接到git仓库方法详见：<a href="https://blog.csdn.net/qq_22494029/article/details/79008386">Github添加SSH</a></li><li><a href="https://www.cnblogs.com/zouwangblog/p/11201561.html">如何上传代码到gitHub</a></li></ul><h4 id="文章提交"><a href="#文章提交" class="headerlink" title="文章提交"></a>文章提交</h4><ul><li>npm install hexo-deployer-git –save</li><li>hexo clean</li><li>hexo generate</li><li>hexo deploy</li></ul><h4 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h4><blockquote><p>拉取代码 git pull</p></blockquote><blockquote><p>提交代码</p><ul><li>git pull</li><li>git add .</li><li>git commit -m ‘’</li><li>git push</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/09/18/hello-world/"/>
    <url>/2020/09/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>通过JavaService将Jar包注册为Windows服务</title>
    <link href="/2020/08/17/JavaServiceForJar/"/>
    <url>/2020/08/17/JavaServiceForJar/</url>
    
    <content type="html"><![CDATA[<blockquote><ul><li>通过cmd命令java -jar运行起来的jar包，在cmd命令终止或窗口关闭时，服务会自动停止。</li><li>解决方案：使用JavaService将jar包注册为服务，使其常驻后台</li></ul></blockquote><ol><li>下载地址：<a href="http://download.forge.ow2.org/javaservice%EF%BC%8C64%E4%BD%8D%E7%B3%BB%E7%BB%9F%EF%BC%88Java%E4%B9%9F%E6%98%AF64%E4%BD%8D%E7%9A%84%EF%BC%89%E7%9A%84%E8%AF%9D%E5%BF%85%E9%A1%BB%E4%B8%8B%E8%BD%BD64%E4%BD%8D%E7%89%88%E6%9C%AC%EF%BC%8C%E6%AF%94%E5%A6%82%EF%BC%9AJavaService_2_0_10-amd64.zip%E3%80%82">http://download.forge.ow2.org/javaservice，64位系统（Java也是64位的）的话必须下载64位版本，比如：JavaService_2_0_10-amd64.zip。</a></li><li>打开CMD窗口，进入JavaService.exe所在目录，输入如下命令：<pre><code class="hljs crystal">JavaService.exe -install deepblog <span class="hljs-string">&quot;%JAVA_HOME%&quot;</span>\jre\bin\server\jvm.dll -Djava.<span class="hljs-keyword">class</span>.path=<span class="hljs-symbol">C:</span>\blogDev\deepblog.jar;<span class="hljs-string">&quot;%JAVA_HOME%&quot;</span>\<span class="hljs-class"><span class="hljs-keyword">lib</span>\<span class="hljs-title">tools</span>.<span class="hljs-title">jar</span> -<span class="hljs-title">Xms64M</span> -<span class="hljs-title">Xmx512M</span> -<span class="hljs-title">start</span> <span class="hljs-title">org</span>.<span class="hljs-title">springframework</span>.<span class="hljs-title">boot</span>.<span class="hljs-title">loader</span>.<span class="hljs-title">JarLauncher</span></span></code></pre></li></ol><p>参数解释：</p><pre><code class="hljs haml">-<span class="ruby">install deepblog：指定服务名，当前注册的服务名为：deepblog</span><span class="ruby">-Djava.<span class="hljs-keyword">class</span>.path=<span class="hljs-symbol">C:</span>\blogDev\deepblog.jar：指定jar包的路径</span><span class="ruby">-start org.springframework.boot.loader.JarLauncher：指定启动类，即 main 函数所在类，需要带上包名</span></code></pre><ol start="3"><li><p>注销服务：</p><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JavaService</span>.</span></span>exe -uninstall deepblog</code></pre></li><li><p>启动服务：</p><pre><code class="hljs dos"><span class="hljs-built_in">net</span> <span class="hljs-built_in">start</span> deepblog</code></pre></li><li><p>停止服务：</p><pre><code class="hljs arduino">net <span class="hljs-built_in">stop</span> deepblog</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaService</tag>
      
      <tag>Jar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中BigDecimal的使用</title>
    <link href="/2019/10/30/JavaForBigDecimal/"/>
    <url>/2019/10/30/JavaForBigDecimal/</url>
    
    <content type="html"><![CDATA[<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><blockquote><ul><li>由于浮点数采用二进制系统表示，而二进制无法精确的表示1/10，好比十进制无法精确表示1/3一样。因此，对于很多值浮点数都是采用其能够表示的离目标值近的数来表示，这有可能会在计算中带来不易察觉的误差。为了解决基本数据类型浮点数不能进行精确计算的问题，Java中专门提供了java.math.BigDecimal类，其提供浮点数的精确计算功能。</li><li>金融类项目，对于金额的计算很敏感，推荐使用BigDecimal用于数据操作</li></ul></blockquote><h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><p>比较：</p><pre><code class="hljs java"><span class="hljs-comment">//使用compareTo方法</span>BigDecimal a, b;a = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;15.64&quot;</span>);b = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;17.45&quot;</span>);<span class="hljs-keyword">if</span> (a.compareTo(b) == -<span class="hljs-number">1</span>) &#123;    System.out.println(<span class="hljs-string">&quot;a小于b&quot;</span>);&#125;<span class="hljs-keyword">if</span> (a.compareTo(b) == <span class="hljs-number">0</span>) &#123;    System.out.println(<span class="hljs-string">&quot;a等于b&quot;</span>);&#125;<span class="hljs-keyword">if</span> (a.compareTo(b) == <span class="hljs-number">1</span>) &#123;    System.out.println(<span class="hljs-string">&quot;a大于b&quot;</span>);&#125;<span class="hljs-keyword">if</span> (a.compareTo(b) &gt; -<span class="hljs-number">1</span>) &#123;    System.out.println(<span class="hljs-string">&quot;a大于等于b&quot;</span>);&#125;<span class="hljs-keyword">if</span> (a.compareTo(b) &lt; <span class="hljs-number">1</span>) &#123;    System.out.println(<span class="hljs-string">&quot;a小于等于b&quot;</span>);&#125;<span class="hljs-comment">//使用min方法</span>BigDecimal bg1, bg2, bg3;bg1 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;184.44&quot;</span>);bg2 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;236&quot;</span>);bg3 = bg1.min(bg2);System.out.println(<span class="hljs-string">&quot;最小值is &quot;</span>+ bg3);</code></pre><p>加减乘除：</p><pre><code class="hljs java">BigDecimal a, b;a = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;8&quot;</span>);b = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;2&quot;</span>);<span class="hljs-comment">//加法</span>System.out.println(<span class="hljs-string">&quot;a加b=&quot;</span>+a.add(b));<span class="hljs-comment">//减法</span>System.out.println(<span class="hljs-string">&quot;a减b=&quot;</span>+a.subtract(b));<span class="hljs-comment">//乘法</span>System.out.println(<span class="hljs-string">&quot;a乘b=&quot;</span>+a.multiply(b));<span class="hljs-comment">//除法</span>System.out.println(<span class="hljs-string">&quot;a除b=&quot;</span>+a.divide(b));<span class="hljs-comment">//绝对值</span>System.out.println(<span class="hljs-string">&quot;a的绝对值=&quot;</span>+a.abs());<span class="hljs-comment">//负值</span>System.out.println(<span class="hljs-string">&quot;a的负值=&quot;</span>+a.negate());</code></pre><p>类型转换：</p><pre><code class="hljs java"><span class="hljs-comment">//BigDecimal类型转为String类型（多用于报文传输或数据库字段转换存储）</span>String str = <span class="hljs-keyword">null</span>;BigDecimal a = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;0.82&quot;</span>);<span class="hljs-keyword">float</span> f = a.floatValue();str = Float.toString(f);System.out.println(str);</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
