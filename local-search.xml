<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Sql索引在哪些场景下会失效</title>
    <link href="/2020/11/17/SqlIndexFailure/"/>
    <url>/2020/11/17/SqlIndexFailure/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>所谓失效。并不真的就是这个索引被删除了。而是在某些情况下，DBMS不会检索索引列表了。执行速度和没有这个索引时的速度一样。<br>但是再执行另外的一条语句，同样的索引又正常起作用。所以索引的失效是针对某条sql语句，某个查询条件的，而不是针对索引本身的。</p>          </div><ol><li><p>索引字段进行判空查询时。也就是对索引字段判断是否为NULL时。语句为is null 或is not null。</p><p> <strong><em>比如：</em></strong></p> <pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> SoftWareDetailInfo <span class="hljs-keyword">where</span> CreateTime <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>;此时就不检索time字段上的索引表了。也就是索引在这条语句执行时失效了。</code></pre><p> <strong><em>接着再执行：</em></strong></p> <pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> SoftWareDetailInfo <span class="hljs-keyword">where</span> CreateTime = <span class="hljs-string">&#x27;2015-04-11 00:00:00&#x27;</span>;此时就会检索索引表了。索引又起作用了。</code></pre></li><li><p>对索引字段进行like查询时。比如：select * from SoftWareDetailInfo where SoftUseLine like ‘%OQC%’。不过网上有的例子说like ‘xx%’索引起作用。我没试过。</p></li><li><p>判断索引列是否不等于某个值时。‘!=’操作符。比如：select * from SoftWareDetailInfo where SoftUseLine != 0</p></li><li><p>对索引列进行运算。这里运算包括+-*/等运算。也包括使用函数。</p><p> <strong><em>比如：</em></strong></p> <pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> SoftWareDetailInfo <span class="hljs-keyword">where</span> SoftUseLine +<span class="hljs-number">0</span>= <span class="hljs-number">0</span>此时索引不起作用。<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> SoftWareDetailInfo <span class="hljs-keyword">where</span> <span class="hljs-keyword">count</span>(SoftUseLine) = <span class="hljs-number">0</span>此时索引也不起作用。</code></pre><p> <strong><em>也就是说如果不是直接判断索引字段列，而是判断运算或其它函数处理后的索引列索引均不起作用。</em></strong></p></li><li><p>复合索引中的前导列没有被作为查询条件。比如：Index_SoftWareDetail索引包含（a，b，c） 三列，但是查询条件里面，没有a，b 列，只有c 列，那么 Index_SoftWareDetail索引也不起作用。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Learn_2.1：RESTful接口与http协议状态表述</title>
    <link href="/2020/09/22/LearnSpringBoot_2.1/"/>
    <url>/2020/09/22/LearnSpringBoot_2.1/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>本文转自<a href="https://www.kancloud.cn/hanxt/springboot2/1177585"><strong>字母哥SpringBoot2.X教程</strong></a><br>很良心的教程文档，作者很有一套，有兴趣的可以去看看</p>          </div><h3 id="一、RESTful风格API的好处"><a href="#一、RESTful风格API的好处" class="headerlink" title="一、RESTful风格API的好处"></a>一、RESTful风格API的好处</h3><p>API（Application Programming Interface），顾名思义：是一组编程接口规范，客户端与服务端通过请求响应进行数据通信。<br>REST（Representational State Transfer）表述性状态传递，决定了接口的形式与规则。<br><strong>RESTful是基于http方法的API设计风格，而不是一种新的技术.</strong></p><ol><li>看Url就知道要什么资源</li><li>看http method就知道针对资源干什么</li><li>看http status code就知道结果如何</li></ol><p>对接口开发提供了一种可以广泛适用的规范，为前端后端交互减少了接口交流的口舌成本，是约定大于配置的体现。通过下面的设计，大家来理解一下这三句话。</p><div class="note note-success">            <p>当然也不是所有的接口，都能用REST的形式来表述。<br>在实际工作中灵活运用，我们用RESTful风格的目的是为大家提供统一标准，避免不必要的沟通成本的浪费，形成一种通用的风格。<br>就好比大家都知道：伸出大拇指表示“你很棒“的意思，绝大部分人都明白，因为你了解了这种风格习惯。但是不排除有些地区伸出大拇指表示其他意思，就不适合使用！</p>          </div><h3 id="二、RESTful-API的设计风格"><a href="#二、RESTful-API的设计风格" class="headerlink" title="二、RESTful API的设计风格"></a>二、RESTful API的设计风格</h3><h4 id="2-1、RESTful是面向资源的（名词）"><a href="#2-1、RESTful是面向资源的（名词）" class="headerlink" title="2.1、RESTful是面向资源的（名词）"></a>2.1、RESTful是面向资源的（名词）</h4><p>REST 通过 URI 暴露资源时，会强调不要在 URI 中出现动词。比如：</p><table><thead><tr><th>不符合REST的接口URI</th><th>符合REST接口URI</th><th>功能</th></tr></thead><tbody><tr><td>GET /api/getDogs/{id}</td><td>GET /api/dogs/{id}</td><td>获取一个小狗</td></tr><tr><td>GET /api/getDogs</td><td>GET /api/dogs</td><td>获取所有小狗</td></tr><tr><td>GET /api/addDogs</td><td>POST /api/dogs</td><td>添加一个小狗</td></tr><tr><td>GET /api/editDogs/{id}</td><td>PUT /api/dogs/{id}</td><td>修改一个小狗</td></tr><tr><td>GET /api/deleteDogs/{id}</td><td>DELETE /api/dogs/{id}</td><td>删除一个小狗</td></tr></tbody></table><h4 id="2-2、用HTTP方法体现对资源的操作（动词）"><a href="#2-2、用HTTP方法体现对资源的操作（动词）" class="headerlink" title="2.2、用HTTP方法体现对资源的操作（动词）"></a>2.2、用HTTP方法体现对资源的操作（动词）</h4><ul><li>GET    ： 获取、读取资源</li><li>POST   ： 添加资源</li><li>PUT    ： 修改资源</li><li>DELETE ： 删除资源</li></ul><p><img src="https://img.kancloud.cn/77/8c/778c1a6b6927d9d4d1b0b038fecf0e38_955x422.png" alt="Http操作"></p><p>实际上，这四个动词实际上就对应着增删改查四个操作，这就利用了HTTP动词来表示对资源的操作。</p><h4 id="2-3-HTTP状态码"><a href="#2-3-HTTP状态码" class="headerlink" title="2.3. HTTP状态码"></a>2.3. HTTP状态码</h4><p>通过HTTP状态码体现动作的结果,不要自定义</p><pre><code class="hljs basic"><span class="hljs-symbol">200 </span>OK <span class="hljs-symbol">400 </span>Bad Request <span class="hljs-symbol">500 </span>Internal Server <span class="hljs-keyword">Error</span></code></pre><p>在 APP 与 API 的交互当中，其结果逃不出这三种状态：</p><ul><li>所有事情都按预期正确执行完毕 - 成功</li><li>APP 发生了一些错误 – 客户端错误（如：校验用户输入身份证，结果输入的是军官证，就是客户端输入错误）</li><li>API 发生了一些错误 – 服务器端错误（各种编码bug或服务内部自己导致的异常）</li></ul><p>这三种状态与上面的状态码是一一对应的。如果你觉得这三种状态，分类处理结果太宽泛，http-status code还有很多。<br>建议还是要遵循KISS(Keep It Stupid and Simple)原则，上面的三种状态码完全可以覆盖99%以上的场景。<br>这三个状态码大家都记得住，而且非常常用，多了就不一定了。</p><h4 id="2-4-Get方法和查询参数不应该改变数据"><a href="#2-4-Get方法和查询参数不应该改变数据" class="headerlink" title="2.4. Get方法和查询参数不应该改变数据"></a>2.4. Get方法和查询参数不应该改变数据</h4><p>改变数据的事交给POST、PUT、DELETE</p><h4 id="2-5-使用复数名词"><a href="#2-5-使用复数名词" class="headerlink" title="2.5. 使用复数名词"></a>2.5. 使用复数名词</h4><p>/dogs 而不是 /dog</p><h4 id="2-6-复杂资源关系的表达"><a href="#2-6-复杂资源关系的表达" class="headerlink" title="2.6. 复杂资源关系的表达"></a>2.6. 复杂资源关系的表达</h4><p>GET /cars/711/drivers/ 返回 使用过编号711汽车的所有司机<br>GET /cars/711/drivers/4 返回 使用过编号711汽车的4号司机</p><h4 id="2-7-高级用法-HATEOAS"><a href="#2-7-高级用法-HATEOAS" class="headerlink" title="2.7. 高级用法:HATEOAS"></a>2.7. 高级用法:HATEOAS</h4><p><strong>HATEOAS</strong>:Hypermedia as the Engine of Application State 超媒体作为应用状态的引擎。<br>RESTful API最好做到HATEOAS，<strong>即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</strong><br>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;link&quot;</span>: &#123;  <span class="hljs-attr">&quot;rel&quot;</span>:   <span class="hljs-string">&quot;collection https://www.example.com/zoos&quot;</span>,  <span class="hljs-attr">&quot;href&quot;</span>:  <span class="hljs-string">&quot;https://api.example.com/zoos&quot;</span>,  <span class="hljs-attr">&quot;title&quot;</span>: <span class="hljs-string">&quot;List of zoos&quot;</span>,  <span class="hljs-attr">&quot;type&quot;</span>:  <span class="hljs-string">&quot;application/vnd.yourformat+json&quot;</span>&#125;&#125;</code></pre><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API或者可以调用什么API了。</p><h4 id="2-8-资源过滤、排序、选择和分页的表述"><a href="#2-8-资源过滤、排序、选择和分页的表述" class="headerlink" title="2.8.资源过滤、排序、选择和分页的表述"></a>2.8.资源过滤、排序、选择和分页的表述</h4><table><thead><tr><th>资源功能表述</th><th>例子</th><th>详细说明</th></tr></thead><tbody><tr><td>资源数据过滤</td><td>GET /cars?color=red</td><td>获取红色的汽车</td></tr><tr><td>资源数据过滤</td><td>GET /cars?seats&lt;=4</td><td>获取小于四座位的汽车</td></tr><tr><td>资源数据排序</td><td>GET /cars?sort=-manufactorer,+model</td><td>获取汽车资源数据，先按照生产者降序排序、再按照车架模型升序排序</td></tr><tr><td>资源数据字段选择</td><td>GET /cars?fields=manufactorer,model,id,color</td><td>只选取其中一些字段，给API消费者一个选择字段的能力，这会降低网络流量</td></tr><tr><td>资源数据分页</td><td>GET /cars?offset=10&amp;limit=5</td><td>使用limit和offset，实现分页、缺省</td></tr></tbody></table><h4 id="2-9-版本化你的API"><a href="#2-9-版本化你的API" class="headerlink" title="2.9. 版本化你的API"></a>2.9. 版本化你的API</h4><p>强制性增加API版本声明，不要发布无版本的API。如：/api/v1/blog<br><strong>面向扩展开放，面向修改关闭</strong>：也就是说一个版本的接口开发完成测试上线之后，我们一般不会对接口进行修改，如果有新的需求就开发新的接口进行功能扩展。<br>这样做的目的是：当你的新接口上线后，不会影响使用老接口的用户。如果新接口目的是替换老接口，也不要在v1版本原接口上修改，而是开发v2版本接口，并声明v1接口废弃！</p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p>关于HTTP RESTful风格API设计的更多例子，请大家参考：<a href="http://httpbin.org/">http://httpbin.org/</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Learn_1.5：IDEA环境下的热加载与热部署</title>
    <link href="/2020/09/22/LearnSpringBoot_1.5/"/>
    <url>/2020/09/22/LearnSpringBoot_1.5/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>本文转自<a href="https://www.kancloud.cn/hanxt/springboot2/1339998"><strong>字母哥SpringBoot2.X教程</strong></a><br>很良心的教程文档，作者很有一套，有兴趣的可以去看看</p>          </div><p>在实际的开发过程中，我们经常修改代码之后，手动的重启项目，手动刷新浏览器查看修改效果。<br>那么有没有一种方式能够快速的、自动的帮我们将修改代码自动更新，避免手动重启，从而提高开发效率呢？<br>肯定是有的，但是对于这个功能很多人对功能的叫法有争议，笔者查询了维基百科、官方文档，没有得到合理的答案，也没有权威的定义。<br>笔者知道的就有：热启动、热加载、热更新、热部署、热切换。<br>这几个词从语义上是有区别的，但是叫什么并不重要，实现了最重要，毕竟绝大部分程序员为了使用这个功能方便开发，也不是专业的搞学术研究的。</p><div class="note note-success">            <p>如果哪位朋友获得了权威渠道的说法，可以将文档连接反馈给我。我再理解一下，争取做到学术研究级别的一丝不苟！在此之前笔者按照自己的想法和英文翻译的角度去使用这些名词。</p>          </div><h3 id="一、使用Jrebel插件"><a href="#一、使用Jrebel插件" class="headerlink" title="一、使用Jrebel插件"></a>一、使用Jrebel插件</h3><p>这是最简单的一种方式，但是有一定的个局限性，Jrebel插件是收费的。虽然有破解方案，但是不建议！有需要的同学自行研究，这里就不多做介绍了。</p><div class="note note-warning">            <p>Jrebel插件在有些Spring Boot版本不够兼容，会报错，越新的版本越容易报错。所以笔者目前还是选择性放弃使用该方法！</p>          </div><p>第一步：安装插件，按照箭头所示选择安装。安装完成之后，要重启IDEA才能生效。<br><img src="https://img.kancloud.cn/b5/86/b5862bc7e81a1d84ea614bf8763feb72_1533x885.png" alt="安装插件"></p><p>第二步：激活。在安装完成之后，右上角会多出这样几个按钮。<br>点击之后会提示你进行插件激活，可以注册码激活，也可以在线激活。也可以填写个人姓名、邮箱、电话之后获取10天的试用！<br><img src="https://img.kancloud.cn/eb/46/eb46dbc880b3b57d634b8a82dfdc65dc_623x225.png" alt="激活"></p><p>第三步：更新操作触发配置，这个配置不仅结合Jrebel使用有效，对于其他的方式实现开发过程中需要自动更新的情况下，也要勾选上。<br><img src="https://img.kancloud.cn/b6/39/b63998ed48839cf7e05346dcc4e15385_497x277.png" alt="更新操作触发配置"></p><p>在Spring Boot项目启动配置中，选择下图中的红色框中的内容：uodate classes and resources on ‘update’ action<br><img src="https://img.kancloud.cn/c1/fd/c1fd71a6e07c941652d4fc3e9b7304b6_1429x863.png" alt="启动配置"><br>配置完成后，通过右上角的JR按钮启动SpringBoot项目。就可以实现改动代码和资源的自动更新。</p><h3 id="二、devtools实现热加载"><a href="#二、devtools实现热加载" class="headerlink" title="二、devtools实现热加载"></a>二、devtools实现热加载</h3><p>这是一种对于SpringBoot而言比较常见的一种实现方式。</p><h4 id="2-1-引入devtools的maven依赖"><a href="#2-1-引入devtools的maven依赖" class="headerlink" title="2.1.引入devtools的maven依赖"></a>2.1.引入devtools的maven依赖</h4><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- devtools --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>spring-boot-devtools从名称就可以看出来，是开发者工具包，其主要的功能就是实现热加载。<br><img src="https://img.kancloud.cn/38/a0/38a0bd94ef6dea1c12046e0f51a16c31_1069x412.png" alt="devtools"><br>其实现原理就是两个ClassLoader<br>一个负责加载那些不会经常改变的文件，比如：第三方jar包，一旦引入项目之后这部分代码在调试过程中就处于不变的状态；<br>一个负责加载可能经常改变的类，比如我们自己在项目中写的代码，被称为restart ClassLoader。<br>当有代码发生改变的时候，重建一个restart ClassLoader，原有的restart ClassLoader被丢掉。由于每次重新加载的内容较少，所以速度比手动重启更快一些。</p><h4 id="2-2-设置IDEA"><a href="#2-2-设置IDEA" class="headerlink" title="2.2.设置IDEA"></a>2.2.设置IDEA</h4><p>首先，运行时编译配置：组合键：“Shift+Ctrl+Alt+/” ，选择 “Registry” ，选中打勾 “compiler.automake.allow.when.app.running” 。<br><img src="https://box.kancloud.cn/974e40a4165195960c5a4a888cbb78e3_1069x322.png" alt="运行时编译"></p><p>其次，自动化编译配置： “File” -&gt; “Settings” -&gt; “Build,Execution,Deplyment” -&gt; “Compiler”，选中打勾 “Make project automatically” 。<br>这是一种重新自动化的编译整体项目的方法。但是笔者一般不这么做，因为IDEA的文件是自动保存的，你想修改一个字符串，<br>有可能你只修改完成第一个字符它就重新编译了，重新加载启动。<br><strong>所以，笔者一般代码修改完成之后，使用Ctrl + F9快捷键对修改类重新编译，而不是做项目的自动化编译。</strong><br><img src="https://img.kancloud.cn/54/b4/54b4462c8b4a3314e4eeb557862e7837_716x424.png" alt="自动化编译配置"></p><p>最后，在一些相对旧的IDEA版本上运行时配置，按如下图形勾选。（新版本IDEA已经不需要了）<br><img src="https://img.kancloud.cn/aa/50/aa50626eecc8c3aebe857f21ad53df2d_688x482.png" alt="旧版本运行时配置"></p><h4 id="2-3-修改一下application-properties配置"><a href="#2-3-修改一下application-properties配置" class="headerlink" title="2.3.修改一下application.properties配置"></a>2.3.修改一下application.properties配置</h4><p>在比较新的Spring Boot devtools版本中我们已经不需要做如下的配置了，但是如果你以上的步骤都完成了，仍然无法实现代码更改之后的热加载，请参考下面的方法。<br>在有些版本我们需要配置热加载生效的开关，使其值等于true。</p><p><strong>下文是properties格式配置，喜欢yml格式的同学可以自行调整一下。</strong><br>默认情况下，支持热加载的目录如下，如果需要其它目录下文件支持热加载需要手动配置：</p><ul><li>/META-INF/maven</li><li>/META-INF/resources</li><li>/resources</li><li>/static</li><li>/public</li><li>/templates</li></ul><pre><code class="hljs yml"><span class="hljs-comment">#热加载生效</span><span class="hljs-string">spring.devtools.restart.enabled=true</span><span class="hljs-comment">#额外新增的热加载目录</span><span class="hljs-string">spring.devtools.restart.additional-paths=</span> <span class="hljs-string">src/main/java</span><span class="hljs-comment">#热加载排除目录</span><span class="hljs-comment">#spring.devtools.restart.exclude= </span></code></pre><h4 id="2-4-LiveReload插件"><a href="#2-4-LiveReload插件" class="headerlink" title="2.4.LiveReload插件"></a>2.4.LiveReload插件</h4><p>最后建议你去chrome 浏览器插件商店安装一个插件叫做LiveReload。<br><img src="https://img.kancloud.cn/bd/91/bd91e4e886709035cba31d16978657c3_2405x798.gif" alt="LiveReload插件"></p><p>Spring devtools默认会启动一个 Live Reload Server实例。<br>监听文件的变化，并实时的与浏览器插件通信，更新浏览器展示界面。<br>这样，你就不用每次更改内容之后都点击浏览器刷新按钮了。</p><h4 id="2-5-最后测试一下"><a href="#2-5-最后测试一下" class="headerlink" title="2.5.最后测试一下"></a>2.5.最后测试一下</h4><p>改一下代码，看看会不会生效。通常不生效的原因有两种：</p><ul><li>JDK编译版本和运行版本不统一，自行学习一下IDEA环境下JDK配置</li><li>浏览器缓存或者其他的缓存软件导致的问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Learn_1.4：提高开发效率必备工具lombok</title>
    <link href="/2020/09/22/LearnSpringBoot_1.4/"/>
    <url>/2020/09/22/LearnSpringBoot_1.4/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>本文转自<a href="https://www.kancloud.cn/hanxt/springboot2/1315474"><strong>字母哥SpringBoot2.X教程</strong></a><br>很良心的教程文档，作者很有一套，有兴趣的可以去看看</p>          </div><h3 id="一、使用lombok插件的好处"><a href="#一、使用lombok插件的好处" class="headerlink" title="一、使用lombok插件的好处"></a>一、使用lombok插件的好处</h3><p>我们在java开发过程中，经常会有一些常规性的，重复性的工作。比如：</p><ul><li>根据成员变量生成get和set方法</li><li>根据成员变量生成类的构造函数</li><li>重写toString()和hashCode方法</li><li>引入日志框架logFactory，用来打印日志<br>以上都是一些重复动作，模板代码。每次都手动生成既浪费时间，又增加了大量的冗余代码。<br>我们可以使用lombok插件来解决这个问题。使我们的编码效率得到大幅度的提高！</li></ul><h3 id="二、如何安装lombok插件"><a href="#二、如何安装lombok插件" class="headerlink" title="二、如何安装lombok插件"></a>二、如何安装lombok插件</h3><p>笔者以InelliJ IDEA为例，安装lombok插件。<br>打开 IDEA 的 File-&gt;Settings 面板，并选择 Plugins 选项，然后点击 “Browse repositories”。<br>在搜索框输入”lombok”，结果中找到lombok点击install，然后重启 IDEA。<br><img src="https://img.kancloud.cn/45/d4/45d483570ca6807eae7de5e6c3ab3cd6_762x511.png" alt="install Lombok"></p><p>我们还要在pom.xml里面加上如下依赖，插件生效。</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- lombok --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><div class="note note-success">            <p>在Spring Boot项目里面不需要加入版本号，spring Boot父项目会代为管理。如果是其他项目，请自行添加版本号！</p>          </div><h3 id="三、使用lombok注解简化开发"><a href="#三、使用lombok注解简化开发" class="headerlink" title="三、使用lombok注解简化开发"></a>三、使用lombok注解简化开发</h3><h4 id="3-1-Data注解"><a href="#3-1-Data注解" class="headerlink" title="3.1.Data注解"></a>3.1.Data注解</h4><p>在java类上使用@Data注解，将为我们在编译期自动生成</p><ul><li>成员变量的get和set方法</li><li>equals方法</li><li>canEqual方法</li><li>hashCode方法</li><li>toString方法</li></ul><p><img src="https://img.kancloud.cn/ab/0a/ab0a2c82558587327f06cca3f094d964_763x473.png" alt="Data注解"></p><p>上图左侧是使用lombok注解Data，右侧是java字节码class文件反编译结果</p><h4 id="3-2-Slf4j注解"><a href="#3-2-Slf4j注解" class="headerlink" title="3.2.Slf4j注解"></a>3.2.Slf4j注解</h4><p>此注解将在编译期自动帮我们引入Logger日志常量，我们在代码中就直接使用log.info或log.debug打印日志即可。下图中红色代码就用Slf4j注解代替就可以了。</p><p><img src="https://img.kancloud.cn/d2/4f/d24f55de1112606f804e9bf6280b3be0_750x441.png" alt="Slf4j注解"></p><h4 id="3-3-Builder注解"><a href="#3-3-Builder注解" class="headerlink" title="3.3.Builder注解"></a>3.3.Builder注解</h4><p>在Java类上使用Builder注解之后，我们可以使用如下代码为对象属性赋值</p><pre><code class="hljs java">LombokPOJO lombokPOJO = LombokPOJO.builder()        .name(<span class="hljs-string">&quot;kobe&quot;</span>)        .age(<span class="hljs-number">39</span>)        .build();</code></pre><p><img src="https://img.kancloud.cn/bd/a3/bda328a18d6acb36be7a3673f2f4122c_1384x862.png" alt="Builder注解"></p><h4 id="3-4-AllArgsConstructor注解"><a href="#3-4-AllArgsConstructor注解" class="headerlink" title="3.4.AllArgsConstructor注解"></a>3.4.AllArgsConstructor注解</h4><p>AllArgsConstructor注解将为我们在编译期自动生成：全参构造函数。</p><p><img src="https://img.kancloud.cn/f9/4f/f94f6763804e87144618e7c9cde0fd5a_1202x466.png" alt="AllArgsConstructor注解"></p><p>有全参构造函数注解，自然就有无参构造函数注解：NoArgsConstructor注解。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>lombok</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Learn_1.3：需要先了解的核心概念</title>
    <link href="/2020/09/22/LearnSpringBoot_1.3/"/>
    <url>/2020/09/22/LearnSpringBoot_1.3/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>本文转自<a href="https://www.kancloud.cn/hanxt/springboot2/1724115"><strong>字母哥SpringBoot2.X教程</strong></a><br>很良心的教程文档，作者很有一套，有兴趣的可以去看看</p>          </div><h3 id="一、Spring、SpringMVC、SpringBoot对比"><a href="#一、Spring、SpringMVC、SpringBoot对比" class="headerlink" title="一、Spring、SpringMVC、SpringBoot对比"></a>一、Spring、SpringMVC、SpringBoot对比</h3><p>SpringBoot项目目的并不是替换Spring、SpringMVC，而是使他们用起来更加简单。<br><strong>Spring</strong><br>Spring框架最核心的特性就是依赖注入DI（Dependency Injecttion）和控制反转IOC（Inversion Of Control）。如果能够合理的使用DI和IOC，可以开发出松耦合、扩展性好的的应用程序。</p><p><strong>SpringMVC</strong><br>Spring MVC提供了一种友好的方式来开发Web应用程序。 通过使用诸如Dispatcher Servlet，ModelAndView和View Resolver，可以轻松开发Web应用程序。</p><p><strong>SpringBoot</strong><br>Spring 和 Spring MVC最大的弊病在于存在大量的配置，并且这些配置在不同的项目中具有很高的相似性。从而导致重复配置，繁琐而且杂乱！<br>Spring Boot期望通过结合自动配置和starters来解决了这个问题。 另外，Spring Boot还提供了一些功能，可以更快地构建可用于生产环境的应用程序。</p><h3 id="二、Spring-Boot-自动配置"><a href="#二、Spring-Boot-自动配置" class="headerlink" title="二、Spring Boot 自动配置"></a>二、Spring Boot 自动配置</h3><p>Spring和Spring MVC应用程序里面有大量的XML或Java Bean配置。Spring Boot为解决这个问题，提供一种新的解决方案，新的思维方式。<br><img src="https://img.kancloud.cn/e0/f3/e0f386d1c8916f4926946d42bf151337_956x578.png" alt="自动配置"><br>SpringBoot思考的方式：是不是可以更加智能一点，当Spring中加入一些新的jar包，加入一些配置，可以自动的影响应用内的bean的加载。 比如：Spring MVC JAR位于类路径中时，自动配置Dispatcher Servlet。当然，当这些自动的默认配置不符合我们的要求的时候，我们可以修改。修改之前加载的这一些Bean，配置修改之后会自动加载另外一些Bean。</p><h3 id="三、什么是Spring-Boot-Starter？"><a href="#三、什么是Spring-Boot-Starter？" class="headerlink" title="三、什么是Spring Boot Starter？"></a>三、什么是Spring Boot Starter？</h3><p>Spring Boot Starter是一组被依赖第三方类库的集合。<br>如果你要开发一个web应用程序，就通过包管理工具(如maven)引入spring-boot-starter-web就可以了，而不用分别引入下面这么多依赖类库，<br>spring-boot-starter-web一次性帮你引入下面的这些常用类库。</p><ul><li>Spring — spring 核心, beans, context上下文, AOP面向切面</li><li>Web MVC — Spring MVC</li><li>Jackson — JSON数据的序列化与反序列化</li><li>Validation — Hibernate参数校验及校验API</li><li>嵌入式 Servlet Container — Tomcat</li><li>日志框架Logging — logback, slf4j</li></ul><p><img src="https://img.kancloud.cn/17/c6/17c6abe1c379cb541484b6844e6b4093_603x545.png" alt="SpringBootStarter"></p><h3 id="四、什么是Spring-Boot-Starter-Parent"><a href="#四、什么是Spring-Boot-Starter-Parent" class="headerlink" title="四、什么是Spring Boot Starter Parent"></a>四、什么是Spring Boot Starter Parent</h3><p>所有的Spring Boot项目默认使用spring-boot-starter-parent作为应用程序的父项目。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre><p>继承父项目的好处在于： 统一java版本配置和其他的一些依赖类库的版本。<br>也就是说，你引入的第三方类库不要加版本号，父项目替你管理版本，而且是经过兼容性测试的。比你自己随便引入一个版本兼容性更好。</p><div class="note note-success">            <p>当然父项目只能帮你管理一些常用类库的版本，如果你引入一些不常用的jar，还是要自己管理版本号及兼容性！</p>          </div><h3 id="五、嵌入式web容器"><a href="#五、嵌入式web容器" class="headerlink" title="五、嵌入式web容器"></a>五、嵌入式web容器</h3><p>Spring boot打成jar包，默认包含嵌入式的web容器：tomcat。你可以简单的使用如下命令启动一个web服务：</p><pre><code class="hljs sh">java -jar springboot-demo.jar</code></pre><p>这更有利于微服务的部署及微服务的构建、启动、扩容。Spring Boot还支持Jetty和Undertow作为web容器。</p><h3 id="六、Spring-Data"><a href="#六、Spring-Data" class="headerlink" title="六、Spring Data"></a>六、Spring Data</h3><p><img src="https://img.kancloud.cn/71/5b/715bd18bdaf7ca530da4857c8da14881_591x305.png" alt="SpringData"></p><p>Spring Data的目标是提供一种更友好的方式或者是API来存取数据。包括对于关系型数据库和NOSQL数据的支持。比如：</p><ul><li>Spring Data JPA — 关系型数据库操作的API，友好且易于使用</li><li>Spring Data MongoDB -MongoDB的操作API</li><li>Spring Data REST — 从持久层Repositories自动生成服务层API，暴露 REST APIs 接口。超级好用！</li></ul><p>当然，Spring Data还有更多好用的特性和支持等待你去探索！</p><h3 id="七、spring-boot2-x新特性"><a href="#七、spring-boot2-x新特性" class="headerlink" title="七、spring boot2.x新特性"></a>七、spring boot2.x新特性</h3><h4 id="7-1-基础环境升级"><a href="#7-1-基础环境升级" class="headerlink" title="7.1.基础环境升级"></a>7.1.基础环境升级</h4><ul><li>最低 JDK 8，支持 JDK 9，不再支持 Java 6 和 7。Spring Boot 2.0 要求 Java 8 作为最低版本，许多现有的 API 已更新，以利用 Java 8 的特性。<br>例如，接口上的默认方法，函数回调以及新的 API，如 javax.time。</li><li>如果你正在使用 Java 7 或更早版本，则在开发 Spring Boot 2.0 应用程序之前，需要升级你的 JDK。<h4 id="7-2-依赖组件升级"><a href="#7-2-依赖组件升级" class="headerlink" title="7.2.依赖组件升级"></a>7.2.依赖组件升级</h4></li><li>Jetty 9.4，Jetty 是一个开源的 Servlet 容器，它为基于 Java 的 Web 内容，例如 JSP 和 Servlet 提供运行环境。Jetty 是使用 Java 语言编写的，它的 API 以一组 JAR 包的形式发布。</li><li>Tomcat 8.5，Apache Tomcat 8.5.x 旨在取代 8.0.x，完全支持 Java 9。</li><li>Flyway 5，Flyway 是独立于数据库的应用、管理并跟踪数据库变更的数据库版本管理工具。用通俗的话讲，Flyway 可以像 SVN 管理不同人的代码那样，管理不同人的 SQL 脚本，从而做到数据库同步。</li><li>Hibernate 5.2，Hibernate 是一款非常流行的 ORM 框架。</li><li>Gradle 3.4，Spring Boot 的 Gradle 插件在很大程度上已被重写，有了重大的改进。</li><li>Thymeleaf 3.0，Thymeleaf 3 相对于 Thymeleaf 2 有非常大的性能提升。<h4 id="7-3-默认软件替换"><a href="#7-3-默认软件替换" class="headerlink" title="7.3. 默认软件替换"></a>7.3. 默认软件替换</h4></li><li>默认数据库连接池已从 Tomcat 切换到 HikariCP，HikariCP 是一个高性能的 JDBC 连接池，Hikari 是日语“光”的意思。</li><li>redis客户端默认使用 Lettuce，替换掉Jedis.Lettuce 是一个可伸缩的线程安全的 Redis 客户端，用于同步、异步和反应使用。多个线程可以共享同一个 RedisConnection，它利用优秀 Netty NIO 框架来高效地管理多个连接，支持先进的 Redis 功能，如 Sentinel、集群、流水线、自动重新连接和 Redis 数据模型。<h4 id="7-4-新技术的引入"><a href="#7-4-新技术的引入" class="headerlink" title="7.4.新技术的引入"></a>7.4.新技术的引入</h4></li><li>响应式编程WebFlux,重要的变革</li><li>支持 Quartz,Spring Boot 1.0 并没有提供对 Quartz 的支持，之前出现了各种集成方案，Spring Boot 2.0 给出了最简单的集成方式。</li><li>对Kotlin 的支持</li><li>JOOQ 的支持,JOOQ 是基于 Java 访问关系型数据库的工具包。JOOQ 既吸取了传统 ORM 操作数据的简单性和安全性，又保留了原生 SQL 的灵活性，它更像是介于 ORMS 和 JDBC 的中间层。<h4 id="7-5-彩蛋"><a href="#7-5-彩蛋" class="headerlink" title="7.5.彩蛋"></a>7.5.彩蛋</h4></li></ul><p><strong>在 Spring Boot 1.0 项目中 src/main/resources 路径下新建一个 banner.txt 文件：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;文件中写入一些字符，启动项目时就会发现默认的 Banner 被替换了。<br><strong>到了 Spring Boot 2.0 现在可以支持 Gif 文件的打印：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot 2.0 在项目启动的时候，会将 Gif 图片的每一个画面，按照顺序打印在日志中，所有的画面打印完毕后，才会启动 Spring Boot 项目。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Learn_1.2：使用IntellijIDEA建立第一个springBoot项目</title>
    <link href="/2020/09/22/LearnSpringBoot_1.2/"/>
    <url>/2020/09/22/LearnSpringBoot_1.2/</url>
    
    <content type="html"><![CDATA[<h3 id="一、使用Maven搭建SpringBoot项目"><a href="#一、使用Maven搭建SpringBoot项目" class="headerlink" title="一、使用Maven搭建SpringBoot项目"></a>一、使用Maven搭建SpringBoot项目</h3><p>由于部分网络原因，没有办法通过Spring Assistant生成SpringBoot项目，故通过新建Maven项目手动配置pom.xml的方式建立项目</p><ol><li>设定groupId等<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.daimon<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>HelloWorld<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>master<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></code></pre></li><li>选取父项目spring-boot-starter-parent，此处使用SpringBoot2.1版本<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre></li><li>SpringBoot默认内嵌的servlet服务器是tomcat，我这里选取undertow替换掉tomcat<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 启动类,去除tomcat --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- undertow --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li>在resources目录新建application.yml配置文件<pre><code class="hljs yml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span></code></pre><h3 id="二、Hello-World示例程序"><a href="#二、Hello-World示例程序" class="headerlink" title="二、Hello World示例程序"></a>二、Hello World示例程序</h3>若使用的Spring Assistant生成SpringBoot项目，可以将application.properties改成application.yml。yml文件和properties配置文件具有同样的功能。二者的区别在于：</li></ol><ul><li>yml文件的层级更加清晰直观，但是书写时需要注意格式缩进对齐。yml格式配置文件更有利于表达复杂数据结构的配置。比如：列表，对象。</li><li>properties阅读上不如yml直观，好处在于书写时不用特别注意格式缩进对齐。</li></ul><ol><li>在com.daimon根路径下新建Application启动类<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.daimon;<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Daimon</span><span class="hljs-comment"> * <span class="hljs-doctag">@Title</span>: HelloWorldApplication</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: TODO</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/9/2215:06</span><span class="hljs-comment"> */</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(HelloWorldApplication.class, args);    &#125;&#125;</code></pre></li><li>一个hello world测试Controller<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.daimon.controller;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Daimon</span><span class="hljs-comment"> * <span class="hljs-doctag">@Title</span>: HelloController</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: TODO</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/9/2215:20</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;    &#125;&#125;</code></pre></li><li>运行HelloWorldApplication，访问<a href="http://localhost:8081/hello%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%A7%81%E5%88%B0%E9%A1%B5%E9%9D%A2%E8%BE%93%E5%87%BA%E5%86%85%E5%AE%B9%E2%80%9Chello">http://localhost:8081/hello，可以见到页面输出内容“hello</a> world”<br>至此，运行成功~<h3 id="三、项目结构目录结构简介"><a href="#三、项目结构目录结构简介" class="headerlink" title="三、项目结构目录结构简介"></a>三、项目结构目录结构简介</h3>项目结构目录整体上符合maven规范要求：<table><thead><tr><th>目录位置</th><th>功能</th></tr></thead><tbody><tr><td>src/main/java</td><td>项目java文件存放位置，初始化包含主程序入口 XxxApplication，可以通过直接运行该类来 启动 Spring Boot应用</td></tr><tr><td>src/main/resources</td><td>存放静态资源，图片、CSS、JavaScript、web页面模板文件等</td></tr><tr><td>src/test</td><td>单元测试代码目录</td></tr><tr><td>target文件夹</td><td>项目代码构建打包结果文件存放位置，不需要人为维护</td></tr><tr><td>pom.xml</td><td>maven项目配置文件</td></tr><tr><td>application.properties（application.yml）</td><td>用于存放程序的各种依赖模块的配置信息，比如服务端口，数据库连接配置等</td></tr></tbody></table></li></ol><ul><li>src/main/resources/static主要用来存放css、图片、js等开发用静态文件</li><li>src/main/resources/public用来存放可以直接用于访问的html文件</li><li>src/main/resources/templates用来存放web开发模板文件</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Learn_1.1：SpringBoot产生背景及优势</title>
    <link href="/2020/09/22/LearnSpringBoot_1.1/"/>
    <url>/2020/09/22/LearnSpringBoot_1.1/</url>
    
    <content type="html"><![CDATA[<h3 id="一、SpringBoot的诞生背景"><a href="#一、SpringBoot的诞生背景" class="headerlink" title="一、SpringBoot的诞生背景"></a>一、SpringBoot的诞生背景</h3><ul><li>随着web项目集成软件的不断增多，xml配置也不断的增多，xml配置文件也在不断地增多，项目的依赖管理也越发的复杂。spring框架也因此饱受争议，配置文件难以理解且容易出错。</li><li>xml配置文件不但复杂，而且绝大部分属于模板配置，也就是说有80%以上的配置是不断重复的。在这个web项目里面这样配置，挪到另一个项目里面这部分配置仍然相同</li></ul><p>因此，像JFinal这种轻量级的web开发框架，因为其简单易用的特性，而逐渐的有了很大发展的空间。Spring社区也逐渐意识到了这个问题，在 2013 年的 SpringOne 2GX 会议上，Pivotal 的 CTO Adrian Colyer 回应了关于spring框架使用复杂度的问题，并且特别提到该平台将来的目标之一就是实现免 XML 配置和提供更佳开发体验。也就是我们今天使用到的spring boot的诞生的主要原因。</p><div class="note note-success">            <p>Spring 开源社区背后有强大的商业公司支持，目前已知的支持力度比较大的公司就是Pivotal 、netflix以及中国的阿里巴巴。</p>          </div><h3 id="二、SpringBoot改变了什么"><a href="#二、SpringBoot改变了什么" class="headerlink" title="二、SpringBoot改变了什么"></a>二、SpringBoot改变了什么</h3><p><strong>举一个例子:自己接电线与标准化插座</strong><br>Spring Boot的配置方式，就像是插头插座，就是这个标准。你第三方开源类库想接入进来，你就按照这个标准做一个starter的适配。<br>spring MVC方式就像是手动接电线，很灵活，但是不同的人接出来的效果千差万别，而且很容易出错。<br>Spring boot虽然灵活性不如Spring MVC的方式，并且你也不太清楚插座里面的线路是什么样，但就是方便易用。</p><p>Spring Boot 的目标不在于为已解决的问题领域提供新的解决方案，而是为平台带来另一种新的开发体验，从而简化对这些已有技术的使用。</p><ul><li>使配置变简单</li><li>使监控变简单</li><li>使部署变简单</li><li>使开发变简单</li></ul><h3 id="三、SpringBoot主要特性"><a href="#三、SpringBoot主要特性" class="headerlink" title="三、SpringBoot主要特性"></a>三、SpringBoot主要特性</h3><ul><li>遵循“约定优于配置”的原则，简化配置</li><li>可以完全脱离XML配置文件,采用注解配置和java Config</li><li>内嵌Servlet容器，应用可用jar包执行：java -jar</li><li>快速完成项目搭建、整合第三方类库，方便易用</li><li>提供了starter POM, 能够非常方便的进行包管理, 简化包管理配置</li><li>与Spring cloud天然集成，spring boot是目前java体系内实现微服务最佳方案</li></ul><h3 id="四、SpringBoot集成第三方类库的步骤"><a href="#四、SpringBoot集成第三方类库的步骤" class="headerlink" title="四、SpringBoot集成第三方类库的步骤"></a>四、SpringBoot集成第三方类库的步骤</h3><ol><li>通过maven引入springboot-XXXX-starter</li><li>修改ymal或properties全局统一配置文件</li><li>加入一个Java Config。这个属于个性化配置，如果使用通用配置，这一步不需要。<br>有哪些官方已经默认集成的类库？请参考：<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter">https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo使用手册</title>
    <link href="/2020/09/18/HexoUserManual/"/>
    <url>/2020/09/18/HexoUserManual/</url>
    
    <content type="html"><![CDATA[<h4 id="主题-amp-快速开始"><a href="#主题-amp-快速开始" class="headerlink" title="主题&amp;快速开始"></a>主题&amp;快速开始</h4><p>选取了<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a>作为博客主题，轻量、快速、美观、功能齐全。</p><ul><li><a href="https://hexo.fluid-dev.com/docs/guide/">官方使用指南</a></li><li><a href="https://hexo.fluid-dev.com/docs/example/">主题操作示例</a></li><li>项目从零搭建教程参考：<a href="https://www.cnblogs.com/visugar/p/6821777.html">hexo从零开始到搭建完整</a></li><li>gitBase设置SSH连接到git仓库方法详见：<a href="https://blog.csdn.net/qq_22494029/article/details/79008386">Github添加SSH</a></li><li><a href="https://www.cnblogs.com/zouwangblog/p/11201561.html">如何上传代码到gitHub</a></li></ul><h4 id="文章提交"><a href="#文章提交" class="headerlink" title="文章提交"></a>文章提交</h4><ul><li>npm install hexo-deployer-git –save</li><li>hexo clean</li><li>hexo generate</li><li>hexo deploy</li></ul><h4 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h4><blockquote><p>拉取代码 git pull</p></blockquote><blockquote><p>提交代码</p><ul><li>git pull</li><li>git add .</li><li>git commit -m ‘’</li><li>git push</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/09/18/hello-world/"/>
    <url>/2020/09/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>通过JavaService将Jar包注册为Windows服务</title>
    <link href="/2020/08/17/JavaServiceForJar/"/>
    <url>/2020/08/17/JavaServiceForJar/</url>
    
    <content type="html"><![CDATA[<blockquote><ul><li>通过cmd命令java -jar运行起来的jar包，在cmd命令终止或窗口关闭时，服务会自动停止。</li><li>解决方案：使用JavaService将jar包注册为服务，使其常驻后台</li></ul></blockquote><ol><li>下载地址：<a href="http://download.forge.ow2.org/javaservice%EF%BC%8C64%E4%BD%8D%E7%B3%BB%E7%BB%9F%EF%BC%88Java%E4%B9%9F%E6%98%AF64%E4%BD%8D%E7%9A%84%EF%BC%89%E7%9A%84%E8%AF%9D%E5%BF%85%E9%A1%BB%E4%B8%8B%E8%BD%BD64%E4%BD%8D%E7%89%88%E6%9C%AC%EF%BC%8C%E6%AF%94%E5%A6%82%EF%BC%9AJavaService_2_0_10-amd64.zip%E3%80%82">http://download.forge.ow2.org/javaservice，64位系统（Java也是64位的）的话必须下载64位版本，比如：JavaService_2_0_10-amd64.zip。</a></li><li>打开CMD窗口，进入JavaService.exe所在目录，输入如下命令：<pre><code class="hljs crystal">JavaService.exe -install deepblog <span class="hljs-string">&quot;%JAVA_HOME%&quot;</span>\jre\bin\server\jvm.dll -Djava.<span class="hljs-keyword">class</span>.path=<span class="hljs-symbol">C:</span>\blogDev\deepblog.jar;<span class="hljs-string">&quot;%JAVA_HOME%&quot;</span>\<span class="hljs-class"><span class="hljs-keyword">lib</span>\<span class="hljs-title">tools</span>.<span class="hljs-title">jar</span> -<span class="hljs-title">Xms64M</span> -<span class="hljs-title">Xmx512M</span> -<span class="hljs-title">start</span> <span class="hljs-title">org</span>.<span class="hljs-title">springframework</span>.<span class="hljs-title">boot</span>.<span class="hljs-title">loader</span>.<span class="hljs-title">JarLauncher</span></span></code></pre></li></ol><p>参数解释：</p><pre><code class="hljs haml">-<span class="ruby">install deepblog：指定服务名，当前注册的服务名为：deepblog</span><span class="ruby">-Djava.<span class="hljs-keyword">class</span>.path=<span class="hljs-symbol">C:</span>\blogDev\deepblog.jar：指定jar包的路径</span><span class="ruby">-start org.springframework.boot.loader.JarLauncher：指定启动类，即 main 函数所在类，需要带上包名</span></code></pre><ol start="3"><li><p>注销服务：</p><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JavaService</span>.</span></span>exe -uninstall deepblog</code></pre></li><li><p>启动服务：</p><pre><code class="hljs dos"><span class="hljs-built_in">net</span> <span class="hljs-built_in">start</span> deepblog</code></pre></li><li><p>停止服务：</p><pre><code class="hljs arduino">net <span class="hljs-built_in">stop</span> deepblog</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaService</tag>
      
      <tag>Jar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中BigDecimal的使用</title>
    <link href="/2019/10/30/JavaForBigDecimal/"/>
    <url>/2019/10/30/JavaForBigDecimal/</url>
    
    <content type="html"><![CDATA[<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><blockquote><ul><li>由于浮点数采用二进制系统表示，而二进制无法精确的表示1/10，好比十进制无法精确表示1/3一样。因此，对于很多值浮点数都是采用其能够表示的离目标值近的数来表示，这有可能会在计算中带来不易察觉的误差。为了解决基本数据类型浮点数不能进行精确计算的问题，Java中专门提供了java.math.BigDecimal类，其提供浮点数的精确计算功能。</li><li>金融类项目，对于金额的计算很敏感，推荐使用BigDecimal用于数据操作</li></ul></blockquote><h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><p>比较：</p><pre><code class="hljs java"><span class="hljs-comment">//使用compareTo方法</span>BigDecimal a, b;a = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;15.64&quot;</span>);b = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;17.45&quot;</span>);<span class="hljs-keyword">if</span> (a.compareTo(b) == -<span class="hljs-number">1</span>) &#123;    System.out.println(<span class="hljs-string">&quot;a小于b&quot;</span>);&#125;<span class="hljs-keyword">if</span> (a.compareTo(b) == <span class="hljs-number">0</span>) &#123;    System.out.println(<span class="hljs-string">&quot;a等于b&quot;</span>);&#125;<span class="hljs-keyword">if</span> (a.compareTo(b) == <span class="hljs-number">1</span>) &#123;    System.out.println(<span class="hljs-string">&quot;a大于b&quot;</span>);&#125;<span class="hljs-keyword">if</span> (a.compareTo(b) &gt; -<span class="hljs-number">1</span>) &#123;    System.out.println(<span class="hljs-string">&quot;a大于等于b&quot;</span>);&#125;<span class="hljs-keyword">if</span> (a.compareTo(b) &lt; <span class="hljs-number">1</span>) &#123;    System.out.println(<span class="hljs-string">&quot;a小于等于b&quot;</span>);&#125;<span class="hljs-comment">//使用min方法</span>BigDecimal bg1, bg2, bg3;bg1 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;184.44&quot;</span>);bg2 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;236&quot;</span>);bg3 = bg1.min(bg2);System.out.println(<span class="hljs-string">&quot;最小值is &quot;</span>+ bg3);</code></pre><p>加减乘除：</p><pre><code class="hljs java">BigDecimal a, b;a = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;8&quot;</span>);b = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;2&quot;</span>);<span class="hljs-comment">//加法</span>System.out.println(<span class="hljs-string">&quot;a加b=&quot;</span>+a.add(b));<span class="hljs-comment">//减法</span>System.out.println(<span class="hljs-string">&quot;a减b=&quot;</span>+a.subtract(b));<span class="hljs-comment">//乘法</span>System.out.println(<span class="hljs-string">&quot;a乘b=&quot;</span>+a.multiply(b));<span class="hljs-comment">//除法</span>System.out.println(<span class="hljs-string">&quot;a除b=&quot;</span>+a.divide(b));<span class="hljs-comment">//绝对值</span>System.out.println(<span class="hljs-string">&quot;a的绝对值=&quot;</span>+a.abs());<span class="hljs-comment">//负值</span>System.out.println(<span class="hljs-string">&quot;a的负值=&quot;</span>+a.negate());</code></pre><p>类型转换：</p><pre><code class="hljs java"><span class="hljs-comment">//BigDecimal类型转为String类型（多用于报文传输或数据库字段转换存储）</span>String str = <span class="hljs-keyword">null</span>;BigDecimal a = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;0.82&quot;</span>);<span class="hljs-keyword">float</span> f = a.floatValue();str = Float.toString(f);System.out.println(str);</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
